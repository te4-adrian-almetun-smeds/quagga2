(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 89);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(162);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(46),
  create: __webpack_require__(47),
  clone: __webpack_require__(94),
  fromValues: __webpack_require__(95),
  copy: __webpack_require__(96),
  set: __webpack_require__(97),
  equals: __webpack_require__(98),
  exactEquals: __webpack_require__(99),
  add: __webpack_require__(100),
  subtract: __webpack_require__(48),
  sub: __webpack_require__(101),
  multiply: __webpack_require__(49),
  mul: __webpack_require__(102),
  divide: __webpack_require__(50),
  div: __webpack_require__(103),
  inverse: __webpack_require__(104),
  min: __webpack_require__(105),
  max: __webpack_require__(106),
  rotate: __webpack_require__(107),
  floor: __webpack_require__(108),
  ceil: __webpack_require__(109),
  round: __webpack_require__(110),
  scale: __webpack_require__(111),
  scaleAndAdd: __webpack_require__(112),
  distance: __webpack_require__(51),
  dist: __webpack_require__(113),
  squaredDistance: __webpack_require__(52),
  sqrDist: __webpack_require__(114),
  length: __webpack_require__(53),
  len: __webpack_require__(115),
  squaredLength: __webpack_require__(54),
  sqrLen: __webpack_require__(116),
  negate: __webpack_require__(117),
  normalize: __webpack_require__(118),
  dot: __webpack_require__(119),
  cross: __webpack_require__(120),
  lerp: __webpack_require__(121),
  random: __webpack_require__(122),
  transformMat2: __webpack_require__(123),
  transformMat2d: __webpack_require__(124),
  transformMat3: __webpack_require__(125),
  transformMat4: __webpack_require__(126),
  forEach: __webpack_require__(127),
  limit: __webpack_require__(128)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(83);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(163),
    createAssigner = __webpack_require__(218);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(228);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(229);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(68);
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    getRawTag = __webpack_require__(176),
    objectToString = __webpack_require__(177);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(86);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if (false) {}

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if (false) {}
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if (false) {}
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if (false) {}

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if (false) {}

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if (false) {}
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if (false) {} // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if (false) {}

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if (false) {}
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if (false) {}
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if (false) {}

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (false) {}

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(69)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(165),
    listCacheDelete = __webpack_require__(166),
    listCacheGet = __webpack_require__(167),
    listCacheHas = __webpack_require__(168),
    listCacheSet = __webpack_require__(169);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(25);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(190);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(205),
    isObjectLike = __webpack_require__(18);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isKey = __webpack_require__(233),
    stringToPath = __webpack_require__(234),
    toString = __webpack_require__(237);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(91);

var iterableToArrayLimit = __webpack_require__(92);

var unsupportedIterableToArray = __webpack_require__(44);

var nonIterableRest = __webpack_require__(93);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(225);

var iterableToArray = __webpack_require__(226);

var unsupportedIterableToArray = __webpack_require__(44);

var nonIterableSpread = __webpack_require__(227);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(249),
  transpose: __webpack_require__(250),
  multiply: __webpack_require__(251),
  identity: __webpack_require__(252),
  adjoint: __webpack_require__(253),
  rotate: __webpack_require__(254),
  invert: __webpack_require__(255),
  create: __webpack_require__(256),
  scale: __webpack_require__(257),
  copy: __webpack_require__(258),
  frob: __webpack_require__(259),
  ldu: __webpack_require__(260)
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(175),
    getValue = __webpack_require__(181);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObject = __webpack_require__(11);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(72);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isLength = __webpack_require__(41);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(42);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(45);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36),
    root = __webpack_require__(17);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(69)))

/***/ }),
/* 69 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(182),
    mapCacheDelete = __webpack_require__(189),
    mapCacheGet = __webpack_require__(191),
    mapCacheHas = __webpack_require__(192),
    mapCacheSet = __webpack_require__(193);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(25);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(204);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17),
    stubFalse = __webpack_require__(207);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(209),
    baseUnary = __webpack_require__(210),
    nodeUtil = __webpack_require__(211);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(25);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(214),
    baseKeysIn = __webpack_require__(216),
    isArrayLike = __webpack_require__(40);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 80 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(220);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(221),
    shortOut = __webpack_require__(223);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(55),
  create: __webpack_require__(56),
  clone: __webpack_require__(129),
  angle: __webpack_require__(130),
  fromValues: __webpack_require__(57),
  copy: __webpack_require__(131),
  set: __webpack_require__(132),
  equals: __webpack_require__(133),
  exactEquals: __webpack_require__(134),
  add: __webpack_require__(135),
  subtract: __webpack_require__(60),
  sub: __webpack_require__(136),
  multiply: __webpack_require__(61),
  mul: __webpack_require__(137),
  divide: __webpack_require__(62),
  div: __webpack_require__(138),
  min: __webpack_require__(139),
  max: __webpack_require__(140),
  floor: __webpack_require__(141),
  ceil: __webpack_require__(142),
  round: __webpack_require__(143),
  scale: __webpack_require__(144),
  scaleAndAdd: __webpack_require__(145),
  distance: __webpack_require__(63),
  dist: __webpack_require__(146),
  squaredDistance: __webpack_require__(64),
  sqrDist: __webpack_require__(147),
  length: __webpack_require__(65),
  len: __webpack_require__(148),
  squaredLength: __webpack_require__(66),
  sqrLen: __webpack_require__(149),
  negate: __webpack_require__(150),
  inverse: __webpack_require__(151),
  normalize: __webpack_require__(58),
  dot: __webpack_require__(59),
  cross: __webpack_require__(152),
  lerp: __webpack_require__(153),
  random: __webpack_require__(154),
  transformMat4: __webpack_require__(155),
  transformMat3: __webpack_require__(156),
  transformQuat: __webpack_require__(157),
  rotateX: __webpack_require__(158),
  rotateY: __webpack_require__(159),
  rotateZ: __webpack_require__(160),
  forEach: __webpack_require__(161)
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(230),
    flatRest = __webpack_require__(244);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = require("get-pixels");

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// NOTE FOR ANYONE IN HERE IN THE FUTURE: This module is used when the module is built for use in Node.
// Webpack.config.js explicitly REPLACES this module with the file called frame_grabber_browser when it is packing the Browser distribution.
var CVUtils = __webpack_require__(10);

var Ndarray = __webpack_require__(261);

var Interp2D = __webpack_require__(262).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (false) {}
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(263);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 91 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(46);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(48);

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(49);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(50);

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(51);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(52);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(47)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(57);

var normalize = __webpack_require__(58);

var dot = __webpack_require__(59);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(55);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(60);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(62);

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 143 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(63);

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(64);

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65);

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(66);

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(56)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 162 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(164),
    assignMergeValue = __webpack_require__(71),
    baseFor = __webpack_require__(194),
    baseMergeDeep = __webpack_require__(196),
    isObject = __webpack_require__(11),
    keysIn = __webpack_require__(79),
    safeGet = __webpack_require__(77);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23),
    stackClear = __webpack_require__(170),
    stackDelete = __webpack_require__(171),
    stackGet = __webpack_require__(172),
    stackHas = __webpack_require__(173),
    stackSet = __webpack_require__(174);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 165 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 171 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 172 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 173 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23),
    Map = __webpack_require__(67),
    MapCache = __webpack_require__(70);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isMasked = __webpack_require__(178),
    isObject = __webpack_require__(11),
    toSource = __webpack_require__(180);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 177 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(179);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 180 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(183),
    ListCache = __webpack_require__(23),
    Map = __webpack_require__(67);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(184),
    hashDelete = __webpack_require__(185),
    hashGet = __webpack_require__(186),
    hashHas = __webpack_require__(187),
    hashSet = __webpack_require__(188);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 185 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 190 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(195);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 195 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(71),
    cloneBuffer = __webpack_require__(197),
    cloneTypedArray = __webpack_require__(198),
    copyArray = __webpack_require__(201),
    initCloneObject = __webpack_require__(202),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(12),
    isArrayLikeObject = __webpack_require__(206),
    isBuffer = __webpack_require__(75),
    isFunction = __webpack_require__(37),
    isObject = __webpack_require__(11),
    isPlainObject = __webpack_require__(208),
    isTypedArray = __webpack_require__(76),
    safeGet = __webpack_require__(77),
    toPlainObject = __webpack_require__(212);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(199);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(200);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 201 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(203),
    getPrototype = __webpack_require__(73),
    isPrototype = __webpack_require__(74);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(11);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 204 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(40),
    isObjectLike = __webpack_require__(18);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 207 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    getPrototype = __webpack_require__(73),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isLength = __webpack_require__(41),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 210 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(68);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(213),
    keysIn = __webpack_require__(79);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(78),
    baseAssignValue = __webpack_require__(38);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(215),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(12),
    isBuffer = __webpack_require__(75),
    isIndex = __webpack_require__(30),
    isTypedArray = __webpack_require__(76);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 215 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(11),
    isPrototype = __webpack_require__(74),
    nativeKeysIn = __webpack_require__(217);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 217 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(219),
    isIterateeCall = __webpack_require__(224);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(80),
    overRest = __webpack_require__(81),
    setToString = __webpack_require__(82);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 220 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(222),
    defineProperty = __webpack_require__(72),
    identity = __webpack_require__(80);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 222 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 223 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(25),
    isArrayLike = __webpack_require__(40),
    isIndex = __webpack_require__(30),
    isObject = __webpack_require__(11);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(45);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 227 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(231),
    hasIn = __webpack_require__(241);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(232),
    baseSet = __webpack_require__(240),
    castPath = __webpack_require__(31);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(31),
    toKey = __webpack_require__(43);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(42);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(235);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(236);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(70);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(238);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    arrayMap = __webpack_require__(239),
    isArray = __webpack_require__(12),
    isSymbol = __webpack_require__(42);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 239 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(78),
    castPath = __webpack_require__(31),
    isIndex = __webpack_require__(30),
    isObject = __webpack_require__(11),
    toKey = __webpack_require__(43);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(242),
    hasPath = __webpack_require__(243);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 242 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(31),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(12),
    isIndex = __webpack_require__(30),
    isLength = __webpack_require__(41),
    toKey = __webpack_require__(43);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(245),
    overRest = __webpack_require__(81),
    setToString = __webpack_require__(82);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(246);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(247),
    isFlattenable = __webpack_require__(248);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 247 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(12);
/** Built-in value references. */


var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 249 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 252 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 257 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 258 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 259 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 261 */
/***/ (function(module, exports) {

module.exports = require("ndarray");

/***/ }),
/* 262 */
/***/ (function(module, exports) {

module.exports = require("ndarray-linear-interpolate");

/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(90);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(9);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  createClass_default()(BarcodeReader, null, [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    value: function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(14);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, merge_default()({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(33);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(15);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (false) {}

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, merge_default()({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if (false) { var $debug; }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (false) {}

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (false) {}
    }

    function initConfig() {
      if (false) { var vis, i; }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if (false) {}

      bresenham.toBinaryLine(barcodeLine);

      if (false) {}

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (false) {}

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if (false) {}

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(16);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(34);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(84);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Error("enumerateDevices is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Error("getUserMedia is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (false) {}

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return pickConstraints(videoConstraints);

            case 2:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
    var tracks = streamRef && streamRef.getVideoTracks();

    if (tracks && tracks.length) {
      tracks[0].stop();
    }

    streamRef = null;
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  false ? undefined :  true ? config_node : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(22);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (false) {}

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(32);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: external "get-pixels"
var external_get_pixels_ = __webpack_require__(87);
var external_get_pixels_default = /*#__PURE__*/__webpack_require__.n(external_get_pixels_);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that
// FOR ANYONE IN HERE IN THE FUTURE: This is the default input_stream module used for the Node bundle.
// webpack.config.js *replaces* this with input_stream_browser.ts when the bundle is being built for browser.

var inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      external_get_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (false) {} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream = (inputStreamFactory);
// EXTERNAL MODULE: ./src/input/frame_grabber.js
var frame_grabber = __webpack_require__(88);
var frame_grabber_default = /*#__PURE__*/__webpack_require__.n(frame_grabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (false) {}

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (false) {}
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (false) {}
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts


















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = frame_grabber_default.a.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$context$config7;

      this.context.stopped = true;
      adjustWorkerPool(0);

      if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
        camera_access.release();
        this.context.inputStream.clearEventHandlers();
      }
    }
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js

 // eslint-disable-line no-unused-vars











var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    instance.start();
  },
  stop: function stop() {
    instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return _context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  false ? undefined : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaW1hZ2VfZGVidWcudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Vwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1YnRyYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bHRpcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1YnRyYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbG9jYXRvci9za2VsZXRvbml6ZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ2V0LXBpeGVsc1wiIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Nsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zyb21WYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXF1YWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2V4YWN0RXF1YWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2FkZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpdi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbnZlcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm90YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zsb29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGVBbmRBZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJEaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJMZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbmVnYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVycC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0Mi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9saW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvaW52ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcm9zcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZXJwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVYLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mb3JFYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9kZXRlcm1pbmFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi90cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvYWRqb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW52ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9jb3B5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2Zyb2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbGR1LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5kYXJyYXlcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZVwiIiwid2VicGFjazovLy8uL3NyYy9kZWNvZGVyL2JyZXNlbmhhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2JhcmNvZGVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8xMjhfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuX3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci91cGNfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RlXzkzX3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2V2ZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL21lZGlhRGV2aWNlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcuZGV2LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLm5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcucHJvZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVhZ2dhQ29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL2luaXRCdWZmZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvZ2V0Vmlld1BvcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9pbml0Q2FudmFzLnRzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvcXdvcmtlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9xdWFnZ2EudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS5qcyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfdHlwZW9mIiwicmVxdWlyZSIsImFzc2VydFRoaXNJbml0aWFsaXplZCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY2FsbCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiRVBTSUxPTiIsImNsb25lIiwiZnJvbVZhbHVlcyIsImNvcHkiLCJzZXQiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsImFkZCIsInN1YnRyYWN0Iiwic3ViIiwibXVsdGlwbHkiLCJtdWwiLCJkaXZpZGUiLCJkaXYiLCJpbnZlcnNlIiwibWluIiwibWF4Iiwicm90YXRlIiwiZmxvb3IiLCJjZWlsIiwicm91bmQiLCJzY2FsZSIsInNjYWxlQW5kQWRkIiwiZGlzdGFuY2UiLCJkaXN0Iiwic3F1YXJlZERpc3RhbmNlIiwic3FyRGlzdCIsImxlbiIsInNxdWFyZWRMZW5ndGgiLCJzcXJMZW4iLCJuZWdhdGUiLCJub3JtYWxpemUiLCJkb3QiLCJjcm9zcyIsImxlcnAiLCJyYW5kb20iLCJ0cmFuc2Zvcm1NYXQyIiwidHJhbnNmb3JtTWF0MmQiLCJ0cmFuc2Zvcm1NYXQzIiwidHJhbnNmb3JtTWF0NCIsImZvckVhY2giLCJsaW1pdCIsImluaXQiLCJhcnIiLCJ2YWwiLCJsIiwic2h1ZmZsZSIsImoiLCJNYXRoIiwieCIsInRvUG9pbnRMaXN0Iiwicm93cyIsInJlZHVjZSIsInAiLCJuIiwicm93Iiwiam9pbiIsInB1c2giLCJ0aHJlc2hvbGQiLCJzY29yZUZ1bmMiLCJxdWV1ZSIsInByZXYiLCJuZXh0IiwiYXBwbHkiLCJtYXhJbmRleCIsInN1bSIsInZlYzIiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwic2l6ZSIsImRhdGEiLCJBcnJheVR5cGUiLCJVaW50OEFycmF5IiwiaW5pdGlhbGl6ZSIsInkiLCJBcnJheUhlbHBlciIsImltZ1JlZiIsImJvcmRlciIsImltYWdlV3JhcHBlciIsImZyb20iLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwid2lkdGgiLCJoZWlnaHQiLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJyZXN1bHQiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsInJhZCIsImlzTmFOIiwiYXRhbiIsInZlYyIsImNvcyIsInNpbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZyYW1lIiwiZ2V0SW1hZ2VEYXRhIiwiZ2V0QXNSR0JBIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsImhzdiIsInJnYiIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJoc3YycmdiIiwicG9zIiwicG9pbnQiLCJwb2ludHMiLCJjZW50ZXIiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInVwZGF0ZUNlbnRlciIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsImNvbXB1dGVJbnRlZ3JhbEltYWdlMiIsImludGVncmFsV3JhcHBlciIsImltYWdlRGF0YSIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInRoaXNDbHVzdGVyIiwiY2x1c3RlcnMiLCJhZGRUb0NsdXN0ZXIiLCJmb3VuZCIsIkNsdXN0ZXIyIiwiVHJhY2VyIiwidHJhY2UiLCJpdGVyYXRpb24iLCJtYXhJdGVyYXRpb25zIiwidG9wIiwiY2VudGVyUG9zIiwiY3VycmVudFBvcyIsImlkeCIsImZvcndhcmQiLCJ0byIsInRvSWR4IiwicHJlZGljdGVkUG9zIiwidGhyZXNob2xkWCIsInRocmVzaG9sZFkiLCJtYXRjaCIsInByZWRpY3RlZCIsIkRJTEFURSIsIkVST0RFIiwiZGlsYXRlIiwiaW5JbWFnZVdyYXBwZXIiLCJvdXRJbWFnZVdyYXBwZXIiLCJpbkltYWdlRGF0YSIsIm91dEltYWdlRGF0YSIsInlTdGFydDEiLCJ5U3RhcnQyIiwieFN0YXJ0MSIsInhTdGFydDIiLCJlcm9kZSIsImFJbWFnZVdyYXBwZXIiLCJiSW1hZ2VXcmFwcGVyIiwicmVzdWx0SW1hZ2VXcmFwcGVyIiwiYUltYWdlRGF0YSIsImJJbWFnZURhdGEiLCJjSW1hZ2VEYXRhIiwiYml0d2lzZU9yIiwiY291bnROb25aZXJvIiwidG9wR2VuZXJpYyIsImxpc3QiLCJtaW5JZHgiLCJzY29yZSIsImhpdCIsIml0ZW0iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJzaW5nbGVDaGFubmVsIiwibG9hZEltYWdlQXJyYXkiLCJzcmMiLCJjYWxsYmFjayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsImIiLCJfY29tcHV0ZURpdmlzb3JzIiwibGFyZ2VEaXZpc29ycyIsImRpdmlzb3JzIiwic3FydCIsInVuc2hpZnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwiYmFzZU1lcmdlIiwiY3JlYXRlQXNzaWduZXIiLCJtZXJnZSIsIm9iamVjdCIsInNvdXJjZSIsInNyY0luZGV4Iiwic3VwZXJQcm9wQmFzZSIsIl9nZXQiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJiYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsImlzT2JqZWN0TGlrZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiZGlyIiwiY3giLCJ2ZXJ0ZXgyRCIsImNvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImJhc2VHZXRUYWciLCJfY29uZmlnIiwiX2N1cnJlbnRJbWFnZVdyYXBwZXIiLCJfc2tlbEltYWdlV3JhcHBlciIsIl9zdWJJbWFnZVdyYXBwZXIiLCJfbGFiZWxJbWFnZVdyYXBwZXIiLCJfcGF0Y2hHcmlkIiwiX3BhdGNoTGFiZWxHcmlkIiwiX2ltYWdlVG9QYXRjaEdyaWQiLCJfYmluYXJ5SW1hZ2VXcmFwcGVyIiwiX3BhdGNoU2l6ZSIsIl9jYW52YXNDb250YWluZXIiLCJiaW5hcnkiLCJkb20iLCJfbnVtUGF0Y2hlcyIsIl9pbnB1dEltYWdlV3JhcHBlciIsIl9za2VsZXRvbml6ZXIiLCJpbml0QnVmZmVycyIsInNrZWxldG9uSW1hZ2VEYXRhIiwiQXJyYXlCdWZmZXIiLCJza2VsZXRvbml6ZXIiLCJ3aW5kb3ciLCJnbG9iYWwiLCJpbml0Q2FudmFzIiwidXNlV29ya2VyIiwiY2xhc3NOYW1lIiwiRU5WIiwiYm94RnJvbVBhdGNoZXMiLCJwYXRjaGVzIiwib3ZlckF2ZyIsInBhdGNoIiwidHJhbnNNYXQiLCJtaW54IiwibWlueSIsIm1heHgiLCJtYXh5IiwiYm94IiwibWF0MiIsImJpbmFyaXplSW1hZ2UiLCJ6ZXJvQm9yZGVyIiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsImNvdW50IiwiZGVzY3JpYmVQYXRjaCIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJhIiwiZmlsdGVyIiwiZWwiLCJmaW5kQm94ZXMiLCJib3hlcyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsImUiLCJzdWJJbWFnZUFzQ29weSIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwiaW5kZXgiLCJyYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eSIsImN1cnJJZHgiLCJub3RZZXRQcm9jZXNzZWQiLCJjdXJyZW50SWR4IiwiY3VycmVudFBhdGNoIiwiaW5wdXRJbWFnZVdyYXBwZXIiLCJsb2NhdGUiLCJjaGVja0ltYWdlQ29uc3RyYWludHMiLCJpbnB1dFN0cmVhbSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwidGhpc0hhbGZTYW1wbGUiLCJnZXRDb25maWciLCJzZXRUb3BSaWdodCIsInNldENhbnZhc1NpemUiLCJzZXRXaWR0aCIsInNldEhlaWdodCIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXMiLCJlcSIsImFzc29jSW5kZXhPZiIsIm90aGVyIiwiZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIl9fZGF0YV9fIiwiYmFzZUlzQXJndW1lbnRzIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJhcmd1bWVudHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwidG9TdHJpbmciLCJjYXN0UGF0aCIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImFyZyIsImluZm8iLCJlcnJvciIsImRvbmUiLCJQcm9taXNlIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZm4iLCJhcmdzIiwiZXJyIiwiZGV0ZXJtaW5hbnQiLCJ0cmFuc3Bvc2UiLCJpZGVudGl0eSIsImFkam9pbnQiLCJpbnZlcnQiLCJmcm9iIiwibGR1IiwiYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJ0YWciLCJiYXNlQXNzaWduVmFsdWUiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNoaWxkcmVuIiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJ0b0tleSIsImFycmF5TGlrZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJzbGljZSIsIm5hbWUiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm91dCIsIkZsb2F0MzJBcnJheSIsInoiLCJNYXAiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJmdW5jIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsImlzUHJvdG90eXBlIiwiQ3RvciIsInByb3RvIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJub2RlVXRpbCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzYWZlR2V0IiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5c0luIiwia2V5c0luIiwibmF0aXZlTWF4Iiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsIm90aGVyQXJncyIsImJhc2VTZXRUb1N0cmluZyIsInNob3J0T3V0Iiwic2V0VG9TdHJpbmciLCJhbmdsZSIsInRyYW5zZm9ybVF1YXQiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJiYXNlUGljayIsImZsYXRSZXN0IiwicGljayIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwiY2MiLCJzYyIsImNvbm5lY3RlZENvdW50IiwiZGVidWciLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiQ1ZVdGlscyIsIk5kYXJyYXkiLCJJbnRlcnAyRCIsImQyIiwiRnJhbWVHcmFiYmVyIiwiX3RoYXQiLCJfdmlkZW9TaXplIiwiZ2V0UmVhbFdpZHRoIiwiZ2V0UmVhbEhlaWdodCIsIl9jYW52YXNTaXplIiwiZ2V0Q2FudmFzU2l6ZSIsIl9zaXplIiwiX3RvcFJpZ2h0IiwiZ2V0VG9wUmlnaHQiLCJfZGF0YSIsIl9ncmF5RGF0YSIsIl9jYW52YXNEYXRhIiwiX2dyYXlJbWFnZUFycmF5IiwiX2NhbnZhc0ltYWdlQXJyYXkiLCJfdGFyZ2V0SW1hZ2VBcnJheSIsImhpIiwibG8iLCJfc3RlcFNpemVYIiwiX3N0ZXBTaXplWSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiZ3JhYiIsImdldEZyYW1lIiwic2NhbGVBbmRDcm9wIiwic2hhcGUiLCJnZXRTaXplIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImFoIiwiYWwiLCJiaCIsImJsIiwiYXNzaWduIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIl9ub25JdGVyYWJsZVJlc3QiLCJhMCIsImExIiwiYjAiLCJiMSIsInQiLCJheCIsImF5Iiwic3RyaWRlIiwibVNxIiwidGVtcEEiLCJ0ZW1wQiIsImNvc2luZSIsImFjb3MiLCJhMiIsImIyIiwiYXoiLCJieCIsImJ5IiwiYnoiLCJ6U2NhbGUiLCJ3IiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInB5IiwicHoiLCJfc2V0UHJvdG90eXBlT2YiLCJTdGFjayIsImJhc2VGb3IiLCJiYXNlTWVyZ2VEZWVwIiwiY3VzdG9taXplciIsInN0YWNrIiwic3JjVmFsdWUiLCJuZXdWYWx1ZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJsYXN0SW5kZXgiLCJwb3AiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInJlcGxhY2UiLCJwYXR0ZXJuIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJIYXNoIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhBU0hfVU5ERUZJTkVEIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsIml0ZXJhdGVlIiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsImNsb25lQnVmZmVyIiwiY2xvbmVUeXBlZEFycmF5IiwiY29weUFycmF5IiwiaW5pdENsb25lT2JqZWN0IiwiaXNBcnJheUxpa2VPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsIm1lcmdlRnVuYyIsInN0YWNrZWQiLCJpc0NvbW1vbiIsImlzQXJyIiwiaXNCdWZmIiwiaXNUeXBlZCIsImFsbG9jVW5zYWZlIiwiaXNEZWVwIiwiY2xvbmVBcnJheUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJieXRlT2Zmc2V0IiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiYmFzZUNyZWF0ZSIsIm9iamVjdENyZWF0ZSIsImFyZ3NUYWciLCJvYmplY3RUYWciLCJvYmplY3RDdG9yU3RyaW5nIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsInR5cGVzIiwiYmluZGluZyIsImNvcHlPYmplY3QiLCJpc05ldyIsImJhc2VUaW1lcyIsImluaGVyaXRlZCIsImlzQXJnIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwidGhpc0FyZyIsImNvbnN0YW50Iiwic3RyaW5nIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc3VwZXJQcm9wQmFzZSIsInJ1bnRpbWUiLCJPcCIsImhhc093biIsIiRTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiQ29udGV4dCIsIl9pbnZva2UiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsInZhbHVlcyIsIkdwIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJtZXRob2QiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsInN0YXRlIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsImNoYXJBdCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiYmFzZVBpY2tCeSIsImhhc0luIiwiYmFzZUdldCIsImJhc2VTZXQiLCJwcmVkaWNhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsImNhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwiYmFzZVRvU3RyaW5nIiwiYXJyYXlNYXAiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwibmVzdGVkIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJmbGF0dGVuIiwiYmFzZUZsYXR0ZW4iLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiZGVwdGgiLCJpc1N0cmljdCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsInBvdyIsIkwiLCJVIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiclRocmVzaG9sZCIsInByaW50RnJlcXVlbmN5IiwicHJpbnRQYXR0ZXJuIiwiZmlsbENvbG9yIiwiZmlsbFJlY3QiLCJCYXJjb2RlRGlyZWN0aW9uIiwiQmFyY29kZVJlYWRlciIsIlN0YXJ0Tm90Rm91bmRFeGNlcHRpb24iLCJDb2RlTm90Rm91bmRFeGNlcHRpb24iLCJQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb24iLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJjb3VudGVyIiwiY29kZSIsIm1heFNpbmdsZUVycm9yIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJfZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiQ29kZTEyOFJlYWRlciIsImJhciIsInNwYWNlIiwiYmVzdE1hdGNoIiwiX2NvcnJlY3QiLCJDT0RFX1BBVFRFUk4iLCJfbWF0Y2hQYXR0ZXJuIiwiQVZHX0NPREVfRVJST1IiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJfbmV4dFNldCIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsInN0YXJ0SW5mbyIsIl9maW5kU3RhcnQiLCJkZWNvZGVkQ29kZXMiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiZnJvbUNoYXJDb2RlIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZmlsbCIsImVwc2lsb24iLCJjb2RlcmFuZ2UiLCJfZmluZFBhdHRlcm4iLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwiX2NhbGN1bGF0ZUZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiU1RPUF9QQVRURVJOIiwiY29uc29sZSIsInJlc3VsdEluZm8iLCJfZGVjb2RlUGF5bG9hZCIsIl9maW5kRW5kIiwiX2NoZWNrc3VtIiwic3VwcGxlbWVudCIsIl9kZWNvZGVFeHRlbnNpb25zIiwibGFzdENvZGUiLCJBTFBIQUJFVEhfU1RSSU5HIiwiQUxQSEFCRVQiLCJVaW50MTZBcnJheSIsImNoYXIiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiQVNURVJJU0siLCJDb2RlMzlSZWFkZXIiLCJwYXR0ZXJuU3RhcnQiLCJfdG9QYXR0ZXJuIiwid2hpdGVTcGFjZU11c3RTdGFydCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJfZmluZE5leHRXaWR0aCIsIm1pbldpZHRoIiwibGFzdFN0YXJ0IiwibmV4dFN0YXJ0IiwicGF0dGVyblNpemUiLCJkZWNvZGVkQ2hhciIsIl90b0NvdW50ZXJzIiwiX3BhdHRlcm5Ub0NoYXIiLCJwYXR0ZXJucyIsIklPUSIsIkFaMDkiLCJDb2RlMzlWSU5SZWFkZXIiLCJfY2hlY2tDaGVja3N1bSIsIlNUQVJUX0VORCIsIk1JTl9FTkNPREVEX0NIQVJTIiwiTUFYX0FDQ0VQVEFCTEUiLCJQQURESU5HIiwiTmV3Q29kYWJhclJlYWRlciIsIl9jb3VudGVycyIsImJhclRocmVzaG9sZCIsIl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQiLCJzcGFjZVRocmVzaG9sZCIsImJpdG1hc2siLCJfaXNTdGFydEVuZCIsIl9zdW1Db3VudGVycyIsInN0YXJ0Q291bnRlciIsImVuZENvdW50ZXIiLCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aCIsImNoYXJDb2RlIiwiY2F0ZWdvcml6YXRpb24iLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiX2NoYXJUb1BhdHRlcm4iLCJraW5kIiwiY2F0IiwibmV3a2luZCIsInRocmVzaG9sZHMiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsIl9maWxsQ291bnRlcnMiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl92YWxpZGF0ZVJlc3VsdCIsIlVQQ1JlYWRlciIsInN1YnN0cmluZyIsIkVBTjhSZWFkZXIiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJDSEVDS19ESUdJVF9FTkNPRElOR1MiLCJkZXRlcm1pbmVDaGVja0RpZ2l0IiwiZXh0ZW5zaW9uQ2hlY2tzdW0iLCJFQU41UmVhZGVyIiwiVVBDRVJlYWRlciIsIl9kZXRlcm1pbmVQYXJpdHkiLCJuclN5c3RlbSIsInVwY2EiLCJsYXN0RGlnaXQiLCJfY29udmVydFRvVVBDQSIsIk4iLCJXIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsImJhclNwYWNlUmF0aW8iLCJuYXJyb3dCYXJXaWR0aCIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJjb3VudGVyTGVuZ3RoIiwiX2RlY29kZVBhaXIiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwiQ29kZTkzUmVhZGVyIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJ3YXJuIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJBRUlPIiwiY29kZTMyc2V0IiwiQ29kZTMyUmVhZGVyIiwicmVzIiwiY29kZTMyIiwiX2RlY29kZUNvZGUzMiIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwicmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIm92ZXJsYXkiLCJfYmFyY29kZVJlYWRlcnMiLCJpbml0UmVhZGVycyIsImluaXRDb25maWciLCJyZWFkZXJzIiwicmVhZGVyQ29uZmlnIiwiY29uZmlndXJhdGlvbiIsInJlYWRlck9iaiIsImdldEV4dGVuZGVkTGluZSIsImV4dCIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJpbkltYWdlV2l0aEJvcmRlciIsImdldExpbmUiLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsImRlY29kZVBhdHRlcm4iLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tSW1hZ2UiLCJkZWNvZGVJbWFnZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwiYmFyY29kZXMiLCJtdWx0aXBsZSIsInNldFJlYWRlcnMiLCJFdmVudEludGVyZmFjZSIsImV2ZW50cyIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIkVSUk9SX0RFU0MiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY29uc3RyYWludHMiLCJzdHJlYW1SZWYiLCJ3YWl0Rm9yVmlkZW8iLCJ2aWRlbyIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJzdHJlYW0iLCJzZXRBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwicGxheSIsImRlcHJlY2F0ZWRDb25zdHJhaW50cyIsInZpZGVvQ29uc3RyYWludHMiLCJtaW5Bc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwibG9nIiwiZmFjaW5nIiwiZmFjaW5nTW9kZSIsInBpY2tDb25zdHJhaW50cyIsImRldmljZUlkIiwiYXVkaW8iLCJlbnVtZXJhdGVWaWRlb0RldmljZXMiLCJkZXZpY2VzIiwiZGV2aWNlIiwiZ2V0QWN0aXZlVHJhY2siLCJ0cmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsIlF1YWdnYUpTQ2FtZXJhQWNjZXNzIiwicmVxdWVzdCIsIm5ld0NvbnN0cmFpbnRzIiwicmVsZWFzZSIsImdldEFjdGl2ZVN0cmVhbUxhYmVsIiwidHJhY2siLCJjb250YWlucyIsInNvbWUiLCJldmVyeSIsInBhc3Nlc0ZpbHRlciIsInJlc3VsdHMiLCJjYXBhY2l0eSIsImNhcHR1cmUiLCJtYXRjaGVzQ29uc3RyYWludHMiLCJibGFja2xpc3QiLCJhZGRSZXN1bHQiLCJpbWFnZVNpemUiLCJJbWFnZURlYnVnIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJkcmF3Qm91bmRpbmdCb3giLCJzaG93RnJlcXVlbmN5IiwiZHJhd1NjYW5saW5lIiwic2hvd1BhdHRlcm4iLCJsb2NhdG9yIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwiY2FudmFzU2l6ZSIsImltYWdlIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsImlucHV0U3RyZWFtRmFjdG9yeSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwibG9hZGVkIiwiYmFzZVVybCIsImVuZGVkIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsIl9ldmVudE5hbWVzIiwiX2V2ZW50SGFuZGxlcnMiLCJmcmFtZUlkeCIsInBhdXNlZCIsImxvYWRJbWFnZXMiLCJHZXRQaXhlbHMiLCJtaW1lIiwicGl4ZWxzIiwicHVibGlzaEV2ZW50IiwiaGFuZGxlcnMiLCJ0cmlnZ2VyIiwic2V0SW5wdXRTdHJlYW0iLCJwYXVzZSIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsImYiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJpbmQiLCJ0b3BSaWdodCIsInN6Iiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwibWVzc2FnZSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJvbm1lc3NhZ2UiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJibG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImluaXRXb3JrZXIiLCJjYiIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJhZGp1c3RXb3JrZXJQb29sIiwiaW5jcmVhc2VCeSIsIndvcmtlcnNUb1Rlcm1pbmF0ZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic2V0dXBJbnB1dFN0cmVhbSIsIklucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJmcmFtZWdyYWJiZXIiLCJjYW52YXNDb250YWluZXIiLCJRV29ya2VycyIsImluaXRpYWxpemVEYXRhIiwicmVhZHkiLCJvblVJVGhyZWFkIiwid29ya2Vyc1VwZGF0ZWQiLCJsb2NhdGVBbmREZWNvZGUiLCJfaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsIl9nZXRWaWV3UG9ydCIsIl9pbml0Q2FudmFzIiwiaW5wdXRUeXBlIiwiQ2FtZXJhQWNjZXNzIiwiY2FuUmVjb3JkIiwiYmluZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVzdWx0Q29sbGVjdG9yIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtR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LENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FITyxFQUlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FKTyxFQUtQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FMTyxFQU1QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FOTyxFQU9QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FQTyxFQVFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FSTyxFQVNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FUTyxFQVVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FWTyxFQVdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FYTyxFQVlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FaTyxFQWFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FiTyxFQWNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FkTyxFQWVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUs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QUFaQSxhQS9INEI7QUFnSTVCOUgsWUFBVSxFQUFWQSw4QkFoSTRCO0FBaUk1QnZ4QyxjQUFZLEVBQVpBLGdDQWpJNEI7QUFrSTVCcTdDLGlCQUFlLEVBQWZBLGdCQUFlQTtBQWxJYSxDQUFoQztBQXFJZVosbUdBQWYsRSxDQUNBIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODkpO1xuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIGludmVyc2U6IHJlcXVpcmUoJy4vaW52ZXJzZScpXG4gICwgbWluOiByZXF1aXJlKCcuL21pbicpXG4gICwgbWF4OiByZXF1aXJlKCcuL21heCcpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgZmxvb3I6IHJlcXVpcmUoJy4vZmxvb3InKVxuICAsIGNlaWw6IHJlcXVpcmUoJy4vY2VpbCcpXG4gICwgcm91bmQ6IHJlcXVpcmUoJy4vcm91bmQnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBzY2FsZUFuZEFkZDogcmVxdWlyZSgnLi9zY2FsZUFuZEFkZCcpXG4gICwgZGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuICAsIGRpc3Q6IHJlcXVpcmUoJy4vZGlzdCcpXG4gICwgc3F1YXJlZERpc3RhbmNlOiByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4gICwgc3FyRGlzdDogcmVxdWlyZSgnLi9zcXJEaXN0JylcbiAgLCBsZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiAgLCBsZW46IHJlcXVpcmUoJy4vbGVuJylcbiAgLCBzcXVhcmVkTGVuZ3RoOiByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuICAsIHNxckxlbjogcmVxdWlyZSgnLi9zcXJMZW4nKVxuICAsIG5lZ2F0ZTogcmVxdWlyZSgnLi9uZWdhdGUnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDI6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MicpXG4gICwgdHJhbnNmb3JtTWF0MmQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MmQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtTWF0NDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQ0JylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxuICAsIGxpbWl0OiByZXF1aXJlKCcuL2xpbWl0Jylcbn1cbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XG4gICAgICAgIC8vIGFyci5maWxsKHZhbCk7XG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIC8vIFRPRE86IGNvZGVfMTI4IHN0YXJ0cyBmYWlsaW5nIG1pc2VyYWJseSB3aGVuIGkgb25seSBhbGxvdyBpbWdSZWYgdG8gY29udGFpbiBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueCk7XG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcbiAgICAvLyBlbmQgb2YgbmV3IGltYWdlV3JhcHBlciBzaXplLlxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgICAvLyB0b29cbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gICAgemVyb0JvcmRlcigpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xuICAgIC8vIGFsbCB0aGUgcmVzdCBvZiBpdCwgc28gdGhpcyBpcyBhIHZlcmJhdGltIGNvcHkgb2YgdGhlIGphdmFzY3JpcHQgc291cmNlLCB3aXRoIG9ubHkgdHdlYWtzXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgbGV0IHlzcTtcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IG11MTE7XG4gICAgICAgIGxldCBtdTAyO1xuICAgICAgICBsZXQgbXUyMDtcbiAgICAgICAgbGV0IHhfO1xuICAgICAgICBsZXQgeV87XG4gICAgICAgIGxldCB0bXA7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBQSV80ID0gUEkgLyA0O1xuXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcbiAgICAgICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXG4gICAgZ2V0QXNSR0JBKHNjYWxlID0gMS4wKTogVWludDhDbGFtcGVkQXJyYXkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiLy8gVE9ETzogY2x1c3Rlci5qcyBhbmQgY3ZfdXRpbHMuanMgYXJlIHByZXR0eSB0aWdodGx5IGludGVydHdpbmVkLCBtYWtpbmcgZm9yIGEgY29tcGxleCBjb252ZXJzaW9uXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXG5cbmltcG9ydCB7IGNsb25lLCBkb3QgfSBmcm9tICdnbC12ZWMyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmUsIGRvdCB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgbGV0IGk7IGxldFxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGNsb25lIGFzIHYyY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGNsb25lIGFzIHYzY2xvbmUgfSBmcm9tICdnbC12ZWMzJztcbmltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmU6IHYyY2xvbmUgfTtcbmNvbnN0IHZlYzMgPSB7IGNsb25lOiB2M2Nsb25lIH07XG5cbi8qKlxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VSZWYoeCwgeSkge1xuICAgIGNvbnN0IHRoYXQgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHRvVmVjMigpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xuICAgICAgICB9LFxuICAgICAgICB0b1ZlYzMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmQoKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueSArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueSAtIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB0aGF0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxuICogQHBhcmFtIGltYWdlRGF0YUNvbnRhaW5lciB7SW1hZ2VEYXRhQ29udGFpbmVyfSB0aGUgaW1hZ2UgdG8gYmUgaW50ZWdyYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHBvc0EgPSAwOyBsZXQgcG9zQiA9IDA7IGxldCBwb3NDID0gMDsgbGV0IHBvc0QgPSAwOyBsZXQgeDsgbGV0XG4gICAgICAgIHk7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3QgY29sdW1uXG4gICAgcG9zQiA9IHdpZHRoO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSArPSB3aWR0aDtcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBwb3NBID0gMDtcbiAgICBwb3NCID0gMTtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSsrO1xuICAgICAgICBwb3NCKys7XG4gICAgfVxuXG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHBvc0EgPSB5ICogd2lkdGggKyAxO1xuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQyA9IHkgKiB3aWR0aDtcbiAgICAgICAgcG9zRCA9ICh5IC0gMSkgKiB3aWR0aDtcbiAgICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0FdXG4gICAgICAgICAgICAgICAgKz0gaW1hZ2VEYXRhW3Bvc0FdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NDXSAtIGludGVncmFsSW1hZ2VEYXRhW3Bvc0RdO1xuICAgICAgICAgICAgcG9zQSsrO1xuICAgICAgICAgICAgcG9zQisrO1xuICAgICAgICAgICAgcG9zQysrO1xuICAgICAgICAgICAgcG9zRCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW2ldO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IHN1bSArIGludGVncmFsSW1hZ2VEYXRhWyh2IC0gMSkgKiB3aWR0aCArIHVdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhOyBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTsgY29uc3RcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgYml0c1BlclBpeGVsID0gODtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGhpc3QgPSBuZXcgSW50MzJBcnJheShidWNrZXRDbnQpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGhpc3RbaW1hZ2VEYXRhW2xlbmd0aF0gPj4gYml0U2hpZnRdKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBsaW5lO1xuICAgIGxldCBsZWZ0ID0gbGluZVswXTtcbiAgICBsZXQgY2VudGVyID0gbGluZVsxXTtcbiAgICBsZXQgcmlnaHQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHJpZ2h0ID0gbGluZVtpICsgMV07XG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgbGluZVtpIC0gMV0gPSAoKChjZW50ZXIgKiAyKSAtIGxlZnQgLSByaWdodCkpICYgMjU1O1xuICAgICAgICBsZWZ0ID0gY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsID0gOCkge1xuICAgIGxldCBoaXN0O1xuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcblxuICAgIGZ1bmN0aW9uIHB4KGluaXQsIGVuZCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaSAqIGhpc3RbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZVRocmVzaG9sZCgpIHtcbiAgICAgICAgY29uc3QgdmV0ID0gWzBdO1xuICAgICAgICBsZXQgcDE7XG4gICAgICAgIGxldCBwMjtcbiAgICAgICAgbGV0IHAxMjtcbiAgICAgICAgbGV0IG0xO1xuICAgICAgICBsZXQgbTI7XG4gICAgICAgIGxldCBtMTI7XG4gICAgICAgIGNvbnN0IG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuXG4gICAgICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBtYXg7IGsrKykge1xuICAgICAgICAgICAgcDEgPSBweCgwLCBrKTtcbiAgICAgICAgICAgIHAyID0gcHgoayArIDEsIG1heCk7XG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xuICAgICAgICAgICAgaWYgKHAxMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAxMiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtMSA9IG14KDAsIGspICogcDI7XG4gICAgICAgICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xuICAgICAgICAgICAgdmV0W2tdID0gbTEyICogbTEyIC8gcDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xuICAgIHJldHVybiB0aHJlc2hvbGQgPDwgYml0U2hpZnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcblxuICAgIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xufVxuXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcik7XG5cbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHY7IGxldCB1OyBjb25zdCBrZXJuZWwgPSAzOyBsZXQgQTsgbGV0IEI7IGxldCBDOyBsZXQgRDsgbGV0IGF2ZzsgY29uc3RcbiAgICAgICAgc2l6ZSA9IChrZXJuZWwgKiAyICsgMSkgKiAoa2VybmVsICogMiArIDEpO1xuXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcbiAgICBmb3IgKHYgPSAwOyB2IDw9IGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygoKGhlaWdodCAtIDEpIC0gdikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhciBvdXQgbGVmdCAmIHJpZ2h0IGJvcmRlclxuICAgIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPD0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2ID0ga2VybmVsICsgMTsgdiA8IGhlaWdodCAtIGtlcm5lbCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSBrZXJuZWwgKyAxOyB1IDwgd2lkdGggLSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgQiA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBDID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBzdW0gPSBEIC0gQyAtIEIgKyBBO1xuICAgICAgICAgICAgYXZnID0gc3VtIC8gKHNpemUpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcbiAgICBsZXQgaTsgbGV0IGs7IGxldCB0aGlzQ2x1c3RlcjsgbGV0IHBvaW50OyBjb25zdFxuICAgICAgICBjbHVzdGVycyA9IFtdO1xuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcHJvcGVydHkgPSAncmFkJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUb0NsdXN0ZXIobmV3UG9pbnQpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjbHVzdGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdGhpc0NsdXN0ZXIgPSBjbHVzdGVyc1trXTtcbiAgICAgICAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXNDbHVzdGVyLmFkZChuZXdQb2ludCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZWFjaCBjbG91ZFxuICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBDbHVzdGVyMi5jcmVhdGVQb2ludChwb2ludHNbaV0sIGksIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xuICAgIHRyYWNlKHBvaW50cywgdmVjKSB7XG4gICAgICAgIGxldCBpdGVyYXRpb247XG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgbGV0IHRvcCA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjZW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgY3VycmVudFBvcyA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XG4gICAgICAgICAgICBsZXQgdG87XG4gICAgICAgICAgICBsZXQgdG9JZHg7XG4gICAgICAgICAgICBsZXQgcHJlZGljdGVkUG9zO1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWCA9IDE7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHBvcywgcHJlZGljdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy54IDwgKHByZWRpY3RlZC54ICsgdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55ID4gKHByZWRpY3RlZC55IC0gdGhyZXNob2xkWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcbiAgICAgICAgICAgIC8vIGlmIG5vdCwgY2hlY2sgYXMgbG9uZyBhcyB0aGUgdGhyZXNob2xkIGlzIG1ldFxuXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcG9pbnRzW2lkeF07XG4gICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyB2ZWNbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggLSB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyBpZHggKyAxIDogaWR4IC0gMTtcbiAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgd2hpbGUgKHRvICYmIChmb3VuZCA9IG1hdGNoKHRvLCBwcmVkaWN0ZWRQb3MpKSAhPT0gdHJ1ZSAmJiAoTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPCB2ZWNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgICAgICAgICAgLy8gcmFuZG9tbHkgc2VsZWN0IHBvaW50IHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgICAgIGNlbnRlclBvcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvaW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyB0cmFjZSBmb3J3YXJkXG4gICAgICAgICAgICB0b3AgPSBbXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRElMQVRFID0gMTtcbmV4cG9ydCBjb25zdCBFUk9ERSA9IDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIGxldCB2O1xuICAgIGxldCB1O1xuICAgIGNvbnN0IGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3Qgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgeVN0YXJ0MTtcbiAgICBsZXQgeVN0YXJ0MjtcbiAgICBsZXQgeFN0YXJ0MTtcbiAgICBsZXQgeFN0YXJ0MjtcblxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPiAwID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcm9kZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA9PT0gNSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gaW1hZ2VXcmFwcGVyO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bSArPSBkYXRhW2xlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XG4gICAgbGV0IGk7IGxldCBtaW5JZHggPSAwOyBsZXQgbWluID0gMDsgY29uc3QgcXVldWUgPSBbXTsgbGV0IHNjb3JlOyBsZXQgaGl0OyBsZXRcbiAgICAgICAgcG9zO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldID0ge1xuICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XG4gICAgICAgIGlmIChzY29yZSA+IG1pbikge1xuICAgICAgICAgICAgaGl0ID0gcXVldWVbbWluSWR4XTtcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgaGl0Lml0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtwb3NdLnNjb3JlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHF1ZXVlW3Bvc10uc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XG4gICAgY3R4LmRyYXdJbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSwgc2l6ZS54LCBzaXplLnkpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjYW52YXNEYXRhLCBzaXplLCBvdXRBcnJheSkge1xuICAgIGxldCB0b3BSb3dJZHggPSAwO1xuICAgIGxldCBib3R0b21Sb3dJZHggPSBzaXplLng7XG4gICAgY29uc3QgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IG91dFdpZHRoID0gc2l6ZS54IC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICBjb25zdCBpbldpZHRoID0gc2l6ZS54O1xuICAgIGxldCBpO1xuXG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbWdJZHhdID0gKFxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMl0pKSAvIDQ7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xuICAgIGNvbnN0IGwgPSAoaW1hZ2VEYXRhLmxlbmd0aCAvIDQpIHwgMDtcbiAgICBjb25zdCBzaW5nbGVDaGFubmVsID0gY29uZmlnICYmIGNvbmZpZy5zaW5nbGVDaGFubmVsID09PSB0cnVlO1xuXG4gICAgaWYgKHNpbmdsZUNoYW5uZWwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSBpbWFnZURhdGFbaSAqIDQgKyAwXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQsXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbGZTYW1wbGUoaW5JbWdXcmFwcGVyLCBvdXRJbWdXcmFwcGVyKSB7XG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBvdXRJbWcgPSBvdXRJbWdXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XG4gICAgY29uc3QgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiID0gWzAsIDAsIDBdKSB7XG4gICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICBjb25zdCBzID0gaHN2WzFdO1xuICAgIGNvbnN0IHYgPSBoc3ZbMl07XG4gICAgY29uc3QgYyA9IHYgKiBzO1xuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XG4gICAgY29uc3QgbSA9IHYgLSBjO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgZyA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBnID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgICAgZyA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgICBnID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMF0gPSAoKHIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZXR1cm4gcmdiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XG4gICAgY29uc3QgbGFyZ2VEaXZpc29ycyA9IFtdO1xuICAgIGNvbnN0IGRpdmlzb3JzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGguc3FydChuKSArIDE7IGkrKykge1xuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIGRpdmlzb3JzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbiAvIGkpIHtcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59XG5cbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKGFycjFbaV0gPiBhcnIyW2pdKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhdGNoU2l6ZShwYXRjaFNpemUsIGltZ1NpemUpIHtcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XG4gICAgY29uc3QgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xuICAgIGNvbnN0IHdpZGVTaWRlID0gTWF0aC5tYXgoaW1nU2l6ZS54LCBpbWdTaXplLnkpO1xuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNNYXAgPSB7XG4gICAgICAgICd4LXNtYWxsJzogNSxcbiAgICAgICAgc21hbGw6IDQsXG4gICAgICAgIG1lZGl1bTogMyxcbiAgICAgICAgbGFyZ2U6IDIsXG4gICAgICAgICd4LWxhcmdlJzogMSxcbiAgICB9O1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XG4gICAgY29uc3QgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdO1xuICAgIGNvbnN0IGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpO1xuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xuXG4gICAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XVxuICAgICAgICAgICAgJiYgZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kID4gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4IC0gMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGNvbW1vbik7XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xuICAgICAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/ICclJyA6ICclJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSA6IG51bGw7XG4gICAgfSxcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSAoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgLSAoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpIDogbnVsbDtcbiAgICB9LFxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xuXG4gICAgY29uc3QgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmVhW2tleV07XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGN1bGF0ZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3g6IHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc3k6IHBhcnNlZEFyZWEudG9wLFxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc2g6IHBhcnNlZEFyZWEuYm90dG9tIC0gcGFyc2VkQXJlYS50b3AsXG4gICAgfTtcbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsImltcG9ydCB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBYWVBvc2l0aW9uIHNob3VsZCBiZSBhbiBYWU9iamVjdCwgYnV0IHRoYXQgYnJlYWtzIFhZRGVmaW5pdGlvbiwgd2hpY2ggYnJlYWtzIGRyYXdQYXRoKCkgYmVsb3cuXG5kZWNsYXJlIGludGVyZmFjZSBYWVBvc2l0aW9uIHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBDYW52YXNTdHlsZSB7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBsaW5lV2lkdGg6IG51bWJlcjtcbn1cblxuLy8gWFlEZWZpbml0aW9uIHRlbGxzIHVzIHdoaWNoIGNvbXBvbmVudCBvZiBhIGdpdmVuIGFycmF5IG9yIG9iamVjdCBpcyB0aGUgXCJYXCIgYW5kIHdoaWNoIGlzIHRoZSBcIllcIi5cbi8vIFVzdWFsbHkgdGhpcyBpcyAwIGZvciBYIGFuZCAxIGZvciBZLCBidXQgbWlnaHQgYmUgdXNlZCBhcyAneCcgZm9yIHggYW5kICd5JyBmb3IgWS5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZRGVmaW5pdGlvbiB7XG4gICAgeDoga2V5b2YgWFlQb3NpdGlvbjtcbiAgICB5OiBrZXlvZiBYWVBvc2l0aW9uO1xufVxuXG5kZWNsYXJlIHR5cGUgUGF0aCA9IEFycmF5PFhZUG9zaXRpb24+O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZHJhd1JlY3QocG9zOiBYWVBvc2l0aW9uLCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHBvcy54LCBwb3MueSwgc2l6ZS54LCBzaXplLnkpO1xuICAgIH0sXG4gICAgZHJhd1BhdGgocGF0aDogUGF0aCwgZGVmOiBYWURlZmluaXRpb24sIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwYXRoW2pdW2RlZi54XSwgcGF0aFtqXVtkZWYueV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgZHJhd0ltYWdlKGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjYW52YXNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY2FudmFzRGF0YTtcbiAgICAgICAgbGV0IGNhbnZhc0RhdGFQb3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGltYWdlRGF0YVBvcyA9IGltYWdlRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW1hZ2VEYXRhW2ltYWdlRGF0YVBvc107XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbn07XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IEN2O1xuICAgICAgICAgICAgbGV0IFA7XG4gICAgICAgICAgICBsZXQgbGRpcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICBkaXI6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC12ZWMyJztcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSAnZ2wtbWF0Mic7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhLFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuXG5cbmxldCBfY29uZmlnO1xubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xubGV0IF9zdWJJbWFnZVdyYXBwZXI7XG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaEdyaWQ7XG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoU2l6ZTtcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgY3R4OiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxuICAgIGRvbToge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbn07XG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbGV0b25pemVyO1xuXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgfVxuXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcihcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCxcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcbiAgICAgICAgc2tlbGV0b25JbWFnZURhdGEsXG4gICAgKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5oZWlnaHQgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcbiAqL1xuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xuICAgIGxldCBvdmVyQXZnO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgdHJhbnNNYXQ7XG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBib3g7XG4gICAgbGV0IHNjYWxlO1xuXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXG4gICAgb3ZlckF2ZyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IG1vbWVudHM7XG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGxldCByYXN0ZXJpemVyO1xuICAgIGxldCByYXN0ZXJSZXN1bHQ7XG4gICAgbGV0IHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcbiAqIGFuZCByZXR1cm5zIHRoZW0gb3JkZXJlZCBERVNDIGJ5IHRoZSBudW1iZXIgb2YgY29udGFpbmVkIHBhdGNoZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxuICovXG5mdW5jdGlvbiBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgbGFiZWxIaXN0ID0gW107XG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heExhYmVsOyBpKyspIHtcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gICAgfVxuICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbEhpc3RbX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSAtIDFdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcbiAgICAgICAgdmFsLFxuICAgICAgICBsYWJlbDogaWR4ICsgMSxcbiAgICB9KSk7XG5cbiAgICBsYWJlbEhpc3Quc29ydCgoYSwgYikgPT4gYi52YWwgLSBhLnZhbCk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcigoZWwpID0+IGVsLnZhbCA+PSA1KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgc3VtO1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IGJveDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xuICAgIGxldCBwb2ludHMgPSBbXTsgY29uc3RcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIGxldCBrO1xuICAgIGxldCBhdmc7XG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XG4gICAgbGV0IG1hdGNoaW5nTW9tZW50cztcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgY29uc3QgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZWxpZ2libGVNb21lbnRzLnB1c2gobW9tZW50c1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTW9tZW50cyA9IHNpbWlsYXJNb21lbnRzKGVsaWdpYmxlTW9tZW50cyk7XG4gICAgICAgICAgICBhdmcgPSAwO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICBsZXQgbGFiZWwgPSAwO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuOTU7XG4gICAgbGV0IGN1cnJJZHggPSAwO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGxldCBkaXI7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgbG9jYXRlKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9LFxuXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcbiAgICAgICAgbGV0IGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdFxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGVcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBhbmdsZTogcmVxdWlyZSgnLi9hbmdsZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1RdWF0OiByZXF1aXJlKCcuL3RyYW5zZm9ybVF1YXQnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG59XG4iLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG4iLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlyOiBudWxsLFxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXG4gICAgICAgICAgICBmaXJzdFZlcnRleDogbnVsbCxcbiAgICAgICAgICAgIGluc2lkZUNvbnRvdXJzOiBudWxsLFxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXG4gICAgICAgICAgICBwcmV2cGVlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDIsXG4gICAgfSxcbiAgICBESVI6IHtcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgICAgIElOU0lERV9FREdFOiAtMzI3NjYsXG4gICAgfSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgYmM7XG4gICAgICAgICAgICAgICAgbGV0IGxjO1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgIGxldCBjeDtcbiAgICAgICAgICAgICAgICBsZXQgY3k7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIGxldCBjYztcbiAgICAgICAgICAgICAgICBsZXQgc2M7XG4gICAgICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xvck1hcFswXSA9IGltYWdlRGF0YVswXTtcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGlxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocS5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHEuZmlyc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocCAhPT0gcS5maXJzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmFzdGVyaXplcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblxuLyogQHByZXNlcnZlIEFTTSBCRUdJTiAqL1xuZnVuY3Rpb24gU2tlbGV0b25pemVyKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XG4gICAgJ3VzZSBhc20nO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3Qgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDA7XG4gICAgY29uc3QgeyBpbXVsIH0gPSBzdGRsaWIuTWF0aDtcblxuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgc3VtID0gKChzdW0gfCAwKSArIChpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3VtIHwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChpbWFnZVB0ciwgdmFsdWUpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgdmFsdWUgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHYgPSAwO1xuICAgICAgICBsZXQgdSA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA+ICgwIHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1jcHkoc3JjSW1hZ2VQdHIsIGRzdEltYWdlUHRyKSB7XG4gICAgICAgIHNyY0ltYWdlUHRyIHw9IDA7XG4gICAgICAgIGRzdEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGRzdEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKGltYWdlc1soc3JjSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB5ID0gMDtcblxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeCkgfCAwXSA9IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8IChzaXplIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tlbGV0b25pemUoKSB7XG4gICAgICAgIGNvbnN0IHN1YkltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IGVyb2RlZEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHRlbXBJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBza2VsSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSAwO1xuXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgICAgIHRlbXBJbWFnZVB0ciA9IChlcm9kZWRJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuXG4gICAgICAgIC8vIGluaXQgc2tlbC1pbWFnZVxuICAgICAgICBpbml0KHNrZWxJbWFnZVB0ciwgMCk7XG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XG4gICAgICAgICAgICBkaWxhdGUoZXJvZGVkSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBzdWJ0cmFjdChzdWJJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xuICAgICAgICAgICAgbWVtY3B5KGVyb2RlZEltYWdlUHRyLCBzdWJJbWFnZVB0cik7XG4gICAgICAgICAgICBzdW0gPSBjb3VudE5vblplcm8oc3ViSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBza2VsZXRvbml6ZSxcbiAgICB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cbmV4cG9ydCBkZWZhdWx0IFNrZWxldG9uaXplcjtcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJnZXQtcGl4ZWxzXCIpOyIsIi8vIE5PVEUgRk9SIEFOWU9ORSBJTiBIRVJFIElOIFRIRSBGVVRVUkU6IFRoaXMgbW9kdWxlIGlzIHVzZWQgd2hlbiB0aGUgbW9kdWxlIGlzIGJ1aWx0IGZvciB1c2UgaW4gTm9kZS5cbi8vIFdlYnBhY2suY29uZmlnLmpzIGV4cGxpY2l0bHkgUkVQTEFDRVMgdGhpcyBtb2R1bGUgd2l0aCB0aGUgZmlsZSBjYWxsZWQgZnJhbWVfZ3JhYmJlcl9icm93c2VyIHdoZW4gaXQgaXMgcGFja2luZyB0aGUgQnJvd3NlciBkaXN0cmlidXRpb24uXG5cbmNvbnN0IENWVXRpbHMgPSByZXF1aXJlKCcuLi9jb21tb24vY3ZfdXRpbHMnKTtcbmNvbnN0IE5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5Jyk7XG5jb25zdCBJbnRlcnAyRCA9IHJlcXVpcmUoJ25kYXJyYXktbGluZWFyLWludGVycG9sYXRlJykuZDI7XG5cbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgX3RvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBsZXQgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgY29uc3QgX2dyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcbiAgICBjb25zdCBfY2FudmFzRGF0YSA9IG5ldyBVaW50OEFycmF5KF9jYW52YXNTaXplLnggKiBfY2FudmFzU2l6ZS55KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4gICAgY29uc3QgX2dyYXlJbWFnZUFycmF5ID0gTmRhcnJheShfZ3JheURhdGEsIFtfdmlkZW9TaXplLnksIF92aWRlb1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcbiAgICBjb25zdCBfY2FudmFzSW1hZ2VBcnJheSA9IE5kYXJyYXkoX2NhbnZhc0RhdGEsIFtfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54XSkudHJhbnNwb3NlKDEsIDApO1xuICAgIGNvbnN0IF90YXJnZXRJbWFnZUFycmF5ID0gX2NhbnZhc0ltYWdlQXJyYXlcbiAgICAgICAgLmhpKF90b3BSaWdodC54ICsgX3NpemUueCwgX3RvcFJpZ2h0LnkgKyBfc2l6ZS55KVxuICAgICAgICAubG8oX3RvcFJpZ2h0LngsIF90b3BSaWdodC55KTtcbiAgICBjb25zdCBfc3RlcFNpemVYID0gX3ZpZGVvU2l6ZS54IC8gX2NhbnZhc1NpemUueDtcbiAgICBjb25zdCBfc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX2dyYXlJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc0ltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICBzdGVwU2l6ZTogW19zdGVwU2l6ZVgsIF9zdGVwU2l6ZVldLFxuICAgICAgICAgICAgc2l6ZTogX3RhcmdldEltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICB0b3BSaWdodDogX3RvcFJpZ2h0LFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVBbmRDcm9wKGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgX3RoYXQuc2NhbGVBbmRDcm9wID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgLy8gMS4gY29tcHV0ZSBmdWxsLXNpemVkIGdyYXkgaW1hZ2VcbiAgICAgICAgQ1ZVdGlscy5jb21wdXRlR3JheShmcmFtZS5kYXRhLCBfZ3JheURhdGEpO1xuXG4gICAgICAgIC8vIDIuIGludGVycG9sYXRlXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX2NhbnZhc1NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgX2NhbnZhc0ltYWdlQXJyYXkuc2V0KHgsIHksIChJbnRlcnAyRChfZ3JheUltYWdlQXJyYXksIHggKiBfc3RlcFNpemVYLCB5ICogX3N0ZXBTaXplWSkpIHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YXJnZXRJbWFnZUFycmF5IG11c3QgYmUgZXF1YWwgdG8gdGFyZ2V0U2l6ZVxuICAgICAgICBpZiAoX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMF0gIT09IF9zaXplLnhcbiAgICAgICAgICAgIHx8IF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzFdICE9PSBfc2l6ZS55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlcyBkbyBub3QgbWF0Y2ghJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBjcm9wXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX3NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIF9kYXRhW3kgKiBfc2l6ZS54ICsgeF0gPSBfdGFyZ2V0SW1hZ2VBcnJheS5nZXQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lR3JhYmJlcjtcbiIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXG4ndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlc1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXhcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIHZlYzIgYnkgYW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBhbmdsZSkge1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV1cblxuICBvdXRbMF0gPSB4ICogYyAtIHkgKiBzXG4gIG91dFsxXSA9IHggKiBzICsgeSAqIGNcblxuICByZXR1cm4gb3V0XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnlcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3NcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgIG91dFswXSA9IG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycFxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb21cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MmRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0M1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGxcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICAgIHN0cmlkZSA9IDJcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDBcbiAgICB9XG4gICAgXG4gICAgaWYoY291bnQpIHtcbiAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBhLmxlbmd0aFxuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgdmVjWzBdID0gYVtpXVxuICAgICAgICB2ZWNbMV0gPSBhW2krMV1cbiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgYVtpXSA9IHZlY1swXVxuICAgICAgICBhW2krMV0gPSB2ZWNbMV1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxpbWl0O1xuXG4vKipcbiAqIExpbWl0IHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIHZhbHVlIHVzZWQgZm9yIHRoZSBgbWF4YFxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSAge3ZlYzJ9IHRoZSB2ZWN0b3IgdG8gbGltaXRcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIG1hZ25pdHVkZSBmb3IgdGhlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsaW1pdChvdXQsIGEsIG1heCkge1xuICB2YXIgbVNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcblxuICBpZiAobVNxID4gbWF4ICogbWF4KSB7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobVNxKTtcbiAgICBvdXRbMF0gPSBhWzBdIC8gbiAqIG1heDtcbiAgICBvdXRbMV0gPSBhWzFdIC8gbiAqIG1heDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5kZXRlcm1pbmFudFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIudHJhbnNwb3NlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhMVxuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYVsxXVxuICAgIG91dFszXSA9IGFbM11cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAYWxpYXMgbWF0Mi5tdWx0aXBseVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdXG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxXG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxXG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzXG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHlcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pZGVudGl0eVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuYWRqb2ludFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9ICBhWzBdXG4gIG91dFswXSA9ICBhWzNdXG4gIG91dFsxXSA9IC1hWzFdXG4gIG91dFsyXSA9IC1hWzJdXG4gIG91dFszXSA9ICBhMFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQGFsaWFzIG1hdDIucm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgcyA9IE1hdGguc2luKHJhZClcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpXG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHNcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogc1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjXG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBhbGlhcyBtYXQyLnNjYWxlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHYwID0gdlswXSwgdjEgPSB2WzFdXG4gIG91dFswXSA9IGEwICogdjBcbiAgb3V0WzFdID0gYTEgKiB2MFxuICBvdXRbMl0gPSBhMiAqIHYxXG4gIG91dFszXSA9IGEzICogdjFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb2JcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmZyb2JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYVswXSwgMikgK1xuICAgIE1hdGgucG93KGFbMV0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzJdLCAyKSArXG4gICAgTWF0aC5wb3coYVszXSwgMilcbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZHVcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIubGR1XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cbmZ1bmN0aW9uIGxkdShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF1cbiAgVVswXSA9IGFbMF1cbiAgVVsxXSA9IGFbMV1cbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXVxuICByZXR1cm4gW0wsIEQsIFVdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZGFycmF5XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIpOyIsImNvbnN0IEJyZXNlbmhhbSA9IHt9O1xuXG5jb25zdCBTbG9wZSA9IHtcbiAgICBESVI6IHtcbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IC0xLFxuICAgIH0sXG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24gKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGxldCB4MCA9IHAxLnggfCAwO1xuICAgIGxldCB5MCA9IHAxLnkgfCAwO1xuICAgIGxldCB4MSA9IHAyLnggfCAwO1xuICAgIGxldCB5MSA9IHAyLnkgfCAwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCB5O1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHg7XG4gICAgY29uc3QgbGluZSA9IFtdO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgdmFsO1xuICAgIGxldCBtaW4gPSAyNTU7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHgxIC0geDA7XG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGFYIC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICBjb25zdCB5U3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgLT0gZGVsdGFZO1xuICAgICAgICBpZiAoZXJyb3IgPCAwKSB7XG4gICAgICAgICAgICB5ICs9IHlTdGVwO1xuICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFYO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgY29uc3QgeyBtaW4gfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IG1heCB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbGluZSB9ID0gcmVzdWx0O1xuICAgIGxldCBzbG9wZTtcbiAgICBsZXQgc2xvcGUyO1xuICAgIGNvbnN0IGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMjtcbiAgICBjb25zdCBleHRyZW1hID0gW107XG4gICAgbGV0IGN1cnJlbnREaXI7XG4gICAgbGV0IGRpcjtcbiAgICBsZXQgdGhyZXNob2xkID0gKG1heCAtIG1pbikgLyAxMjtcbiAgICBjb25zdCByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICB2YWw6IGxpbmVbMF0sXG4gICAgfSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudERpciA9IGRpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IGxpbmUubGVuZ3RoLFxuICAgICAgICB2YWw6IGxpbmVbbGluZS5sZW5ndGggLSAxXSxcbiAgICB9KTtcblxuICAgIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xuICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IGNlbnRlciA/IDAgOiAxO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBleHRyZW1hIGFuZCBjb252ZXJ0IHRvIGJpbmFyeSBiYXNlZCBvbiBhdmcgYmV0d2VlbiBtaW5tYXhcbiAgICBmb3IgKGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXNlZCBmb3IgZGV2ZWxvcG1lbnQgb25seVxuICovXG5CcmVzZW5oYW0uZGVidWcgPSB7XG4gICAgcHJpbnRGcmVxdWVuY3kobGluZSwgY2FudmFzKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IGxldFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG4iLCJpbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmV4cG9ydCBlbnVtIEJhcmNvZGVEaXJlY3Rpb24ge1xuICAgIEZvcndhcmQgPSAxLFxuICAgIFJldmVyc2UgPSAtMSxcbn07XG5cbmV4cG9ydCB0eXBlIEJhcmNvZGVSZWFkZXJUeXBlID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgQmFyY29kZUZvcm1hdCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUmVhZGVyQ29uZmlnIHtcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoPzogYm9vbGVhbixcbiAgICBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXJUeXBlPixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUNvcnJlY3Rpb24ge1xuICAgIGJhcjogbnVtYmVyLFxuICAgIHNwYWNlOiBudW1iZXIsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydENvdW50ZXI/OiBudW1iZXIsXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kQ291bnRlcj86IG51bWJlcixcbiAgICBlcnJvcj86IG51bWJlcixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUluZm8gZXh0ZW5kcyBCYXJjb2RlUG9zaXRpb24ge1xuICAgIGNvZGU6IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGUge1xuICAgIGNvZGU6IHN0cmluZyxcbiAgICBjb2Rlc2V0PzogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXG4gICAgZGlyZWN0aW9uPzogQmFyY29kZURpcmVjdGlvbixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxuICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxufTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9yb3c6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICBjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDA7XG4gICAgRk9STUFUOiBCYXJjb2RlRm9ybWF0ID0gJ3Vua25vd24nO1xuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgLy8gVE9ETzogc2hvdWxkIGFkZCBBTFBIQUJFVEhfU1RSSU5HLCBBTFBIQUJFVCwgQ0hBUkFDVEVSX0VOQ09ESU5HUyB0byBiYXNlIGNsYXNzLCBpZiB0aGV5XG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXG5cbiAgICBhYnN0cmFjdCBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG5cbiAgICAgICAgdGhpcy5fcm93ID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfbmV4dFVuc2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgc3RhcnQ6IG51bWJlciA9IDApOiBudW1iZXIge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBtYXhTaW5nbGVFcnJvcj86IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGxldCBzaW5nbGVFcnJvciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbW9kdWxvID0gMDtcbiAgICAgICAgbGV0IGJhcldpZHRoID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHNjYWxlZCA9IDA7XG5cbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgPSBtYXhTaW5nbGVFcnJvciB8fCB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SIHx8IDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdW0gPCBtb2R1bG8pIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XG4gICAgICAgIG1heFNpbmdsZUVycm9yICo9IGJhcldpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcbiAgICAgICAgICAgIHNjYWxlZCA9IGNvZGVbaV0gKiBiYXJXaWR0aDtcbiAgICAgICAgICAgIHNpbmdsZUVycm9yID0gTWF0aC5hYnMoY291bnQgLSBzY2FsZWQpIC8gc2NhbGVkO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbiAgICB9XG5cbiAgICBfbmV4dFNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdG1wID0gY291bnRlcltpbmRpY2VzW2xlbmd0aF1dICogKDEgLSAoKDEgLSBjb3JyZWN0aW9uKSAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0bXAgPiAxKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjb2RlUGF0dGVybihwYXR0ZXJuOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XG4gICAgICAgIHRoaXMuX3JvdyA9IHBhdHRlcm47XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuIGNhbGxpbmcgZGVjb2RlJywgdHlwZW9mIHRoaXMsIHRoaXMuY29uc3RydWN0b3IsIHRoaXMuRk9STUFULCBKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0IHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV2ZXJzZWQgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uUmV2ZXJzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmZvcm1hdCA9IHRoaXMuRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9tYXRjaFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2ZpbGxDb3VudGVycyhvZmZzZXQ6IG51bWJlciA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpLCBlbmQ6IG51bWJlciA9IHRoaXMuX3Jvdy5sZW5ndGgsIGlzV2hpdGU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgQ29kZTEyOFJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIENPREVfU0hJRlQgPSA5ODtcbiAgICBDT0RFX0MgPSA5OTtcbiAgICBDT0RFX0IgPSAxMDA7XG4gICAgQ09ERV9BID0gMTAxO1xuICAgIFNUQVJUX0NPREVfQSA9IDEwMztcbiAgICBTVEFSVF9DT0RFX0IgPSAxMDQ7XG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xuICAgIFNUT1BfQ09ERSA9IDEwNjtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMywgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMywgMywgMSwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMywgMywgMiwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMywgMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbNCwgMSwgMywgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMSwgNCwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl0sXG4gICAgICAgIF07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcbiAgICBGT1JNQVQgPSAnY29kZV8xMjgnO1xuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xuXG4gICAgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9jb3JyZWN0KGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IEJhcmNvZGVDb3JyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uYmFyLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IHRoaXMuU1RBUlRfQ09ERV9BOyBjb2RlIDw9IHRoaXMuU1RBUlRfQ09ERV9DOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgLy8gICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgbXVsdGlwbGllciA9IDAsXG4gICAgICAgIC8vICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAgIC8vICAgICBjb2Rlc2V0LFxuICAgICAgICAvLyAgICAgcmF3UmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgLy8gICAgIHNoaWZ0TmV4dCA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgdW5zaGlmdCxcbiAgICAgICAgLy8gICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBjb2RlOiBzdGFydEluZm8uY29kZSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiBzdGFydEluZm8uY29ycmVjdGlvbi5iYXIsXG4gICAgICAgICAgICAgICAgc3BhY2U6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLnNwYWNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICAgIGxldCBjb2Rlc2V0ID0gKChjOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShjb2RlLmNvZGUpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICBsZXQgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW107IC8vIFRPRE86IGkgdGhpbmsgdGhpcyBzaG91bGQgYmUgc3RyaW5nIG9ubHksIGJ1dCBpdCBjcmVhdGVzIHByb2JsZW1zIGlmIGl0IGlzXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gY29kZXNldCA9PT0gdGhpcy5DT0RFX0EgPyB0aGlzLkNPREVfQiA6IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgY29kZXNldDogY29kZXNldCBhcyBudW1iZXIsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kSW5mbzogY29kZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcblxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBjYWxjdWxhdGVDb3JyZWN0aW9uKGV4cGVjdGVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG5vcm1hbGl6ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogbnVtYmVyIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXG4gICAgICAgICAgICBzdW1FeHBlY3RlZCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW1FeHBlY3RlZCArPSBleHBlY3RlZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCArPSBub3JtYWxpemVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bUV4cGVjdGVkIC8gc3VtTm9ybWFsaXplZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUxMjhSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb2RlcmFuZ2U/OiBudW1iZXIpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZScsIHN0YXJ0LCBjb2RlcmFuZ2UpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYmVmb3JlIGxlbmd0aCcpO1xuICAgICAgICAgICAgY29kZXJhbmdlID0gQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGFmdGVyIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHN0YXJ0SW5mbz0nLCBKU09OLnN0cmluZ2lmeShzdGFydEluZm8pKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgc3RhcnRJbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGNhbGN1bGF0ZUZpcnN0RGlnaXQnLCBjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENPREVfRlJFUVVFTkNZW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC09IENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSB0aGlzLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcblxuICAgICAgICBsZXQgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBvdXRDb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm49JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZGVjb2RlQ29kZShtaWRkbGVQYXR0ZXJuIS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgICAgIGlmICghbWlkZGxlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgcmVzdWx0PScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZWRDb2Rlcz0nLCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICByZXR1cm4gbWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZScsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcblxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRFbmQnLCBvZmZzZXQsIGlzV2hpdGUpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogX2NoZWNrc3VtJywgcmVzdWx0KTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSAqPSAzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xuICAgICAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQ6IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMnLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoZXJlIGFyZSAnLCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCwgJyBzdXBwbGVtZW50cycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBleHRlbnNpb25zIGxvb3AnLCBpLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyUnO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgwMzQsIDB4MTIxLCAweDA2MSwgMHgxNjAsIDB4MDMxLCAweDEzMCwgMHgwNzAsIDB4MDI1LCAweDEyNCwgMHgwNjQsIDB4MTA5LCAweDA0OSxcbiAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDA5NDtcblxuY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzknO1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhOYXJyb3dXaWR0aCA9IDA7XG4gICAgICAgIGxldCBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzO1xuICAgICAgICBsZXQgd2lkZUJhcldpZHRoID0gMDtcblxuICAgICAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XG4gICAgICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgICAgIG51bVdpZGVCYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1XaWRlQmFycyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgX2ZpbmROZXh0V2lkdGgoY291bnRlcnM6IFVpbnQxNkFycmF5LCBjdXJyZW50OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbldpZHRoO1xuICAgIH07XG5cbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG5cbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gcGF0dGVyblNpemU7XG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5UmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vLFxufTtcblxuY2xhc3MgQ29kZTM5VklOUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOV92aW4nO1xuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuSU9RLCAnJyk7XG5cbiAgICAgICAgaWYgKCFjb2RlLm1hdGNoKHBhdHRlcm5zLkFaMDkpKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9XG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBTVEFSVF9FTkQgPSBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XG5jb25zdCBQQURESU5HID0gMS41O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGNvdW50czogbnVtYmVyLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZCB7XG4gICAgc3BhY2U6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxufTtcblxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9jb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcblxuICAgIF9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgobWluICsgbWF4KSAvIDIuMCkgfCAwO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XG5cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcblxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDB4MDtcbiAgICB9O1xuXG4gICAgX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XG4gICAgICAgICAgICAgICAgc3BhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgKFsnc3BhY2UnLCAnYmFyJ10gYXMgY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgbmV3a2luZCA9IGNhdGVnb3JpemF0aW9uW2tleV07XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICAgICAgbmV3a2luZC5uYXJyb3cubWF4ID0gTWF0aC5jZWlsKG5ld2tpbmQud2lkZS5taW4pO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgICB9O1xuXG4gICAgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICd1cGNfYSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuXG5jbGFzcyBFQU4yUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzInO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoMSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQpICE9PSBjb2RlRnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU4yUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBDSEVDS19ESUdJVF9FTkNPRElOR1MgPSBbMjQsIDIwLCAxOCwgMTcsIDEyLCA2LCAzLCAxMCwgOSwgNV07XG5cbmZ1bmN0aW9uIGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDSEVDS19ESUdJVF9FTkNPRElOR1NbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICBjb25zdCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICByZXR1cm4gc3VtICUgMTA7XG59XG5cbmNsYXNzIEVBTjVSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fNSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg0IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb25DaGVja3N1bShyZXN1bHQpICE9PSBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU41UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG5cbiAgICBfZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3k6IG51bWJlciwgcmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGZvciAobGV0IG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKyl7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG5yU3lzdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jb252ZXJ0VG9VUENBKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiB1cGNhO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuIiwiLy8gVE9ETzogaTJvZjVfcmVhZGVyIGFuZCAyb2Y1X3JlYWRlciBzaGFyZSB2ZXJ5IHNpbWlsYXIgY29kZSwgbWFrZSB1c2Ugb2YgdGhhdFxuXG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcblxuY2xhc3MgSTJvZjVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XG5cbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcbiAgICBdO1xuICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiA9IDU7XG4gICAgRk9STUFUID0gJ2kyb2Y1JztcblxuICAgIGNvbnN0cnVjdG9yKG9wdHM6IEJhcmNvZGVSZWFkZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlclN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvID0gdGhpcy5NQVhfQ09SUkVDVElPTl9GQUNUT1I7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hQYXR0ZXJuLmNhbGwodGhpcywgY291bnRlciwgY29kZSk7XG4gICAgfTtcblxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldD86IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiA9IGZhbHNlLCB0cnlIYXJkZXI6IGJvb2xlYW4gPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gNCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiAxMDtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZmluZEVuZCgpIHtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZVBhaXIoY291bnRlclBhaXI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IGNvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQYWlyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyUGFpcltpXSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZVBvc2l0aW9uPigpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMiAhPT0gMCB8fFxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBJMm9mNVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbVywgTiwgVywgTiwgTiwgTl07XG5jb25zdCBTVE9QX1BBVFRFUk4gPSBbVywgTiwgTiwgTiwgV107XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgW04sIE4sIFcsIFcsIE5dLFxuICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgW1csIFcsIE4sIE4sIE5dLFxuICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgW04sIFcsIFcsIE4sIE5dLFxuICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgW04sIFcsIE4sIFcsIE5dLFxuXTtcbmNvbnN0IFNUQVJUX1BBVFRFUk5fTEVOR1RIID0gU1RBUlRfUEFUVEVSTi5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuXG5jbGFzcyBUd29PZkZpdmVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuXG4gICAgRk9STUFUID0gJzJvZjUnO1xuXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuXG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGUgPSBmYWxzZSwgdHJ5SGFyZGVyID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgfVxuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbykge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZmluZEVuZCgpIHtcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgX2RlY29kZUNvZGUoY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBDT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7Y29kZS5jb2RlfWApO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gJC8rJWFiY2QqJztcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLFxuICAgIDB4MUE4LCAweDFBNCwgMHgxQTIsIDB4MTk0LCAweDE5MiwgMHgxOEEsIDB4MTY4LCAweDE2NCwgMHgxNjIsIDB4MTM0LFxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxuICAgIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLFxuICAgIDB4MTZFLCAweDE3NiwgMHgxQUUsIDB4MTI2LCAweDFEQSwgMHgxRDYsIDB4MTMyLCAweDE1RSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDE1RTtcblxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfOTMnO1xuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gTWF0aC5yb3VuZChjb3VudGVyc1tpXSAqIDkgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA8PD0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGxhc3RTdGFydCA9PT0gbmV4dFN0YXJ0IHx8ICF0aGlzLl9yb3dbbmV4dFN0YXJ0XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoYXJBcnJheS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAobGVuZ3RoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhckFycmF5WysraV07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gbmV4dENoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDM4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdLJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnUCcgJiYgbmV4dENoYXIgPD0gJ1MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBjb2RlXzkzX3JlYWRlciBfZGVjb2RlRXh0ZW5kZWQgaGl0IGRlZmF1bHQgY2FzZSwgdGhpcyBtYXkgYmUgYW4gZXJyb3InLCBkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBhcnJheVRvQ2hlY2sgPSBjaGFyQXJyYXkuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9ICgoKGkgKiAtMSkgKyAobGVuZ3RoIC0gMSkpICUgbWF4V2VpZ2h0KSArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5Q2hlY2tzdW1zKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXG4gICAgICAgICAgICAmJiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAxLCAxNSk7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmc+IHwgbnVsbCA9IFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ7XG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tzdW1zKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcbiAgICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXG4gICAgICAgIGlmICgocmVzdWx0ID0gdGhpcy5fZGVjb2RlRXh0ZW5kZWQocmVzdWx0KSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBBRUlPOiAvW0FFSU9dL2csXG4gICAgQVowOTogL1tBLVowLTldLyxcbn07XG5cbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XG5cbmNsYXNzIENvZGUzMlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcblxuICAgIF9kZWNvZGVDb2RlMzIoY29kZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICgvW14wLTlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaXS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gcmVzICogMzIgKyBjb2RlMzJzZXQuaW5kZXhPZihjb2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZTMyID0gJycgKyByZXM7XG4gICAgICAgIGlmIChjb2RlMzIubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgY29kZTMyID0gKCcwMDAwMDAwMDAnICsgY29kZTMyKS5zbGljZSgtOSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdBJyArIGNvZGUzMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuX2RlY29kZShyb3csIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlMzIgPSB0aGlzLl9kZWNvZGVDb2RlMzIoY29kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNvZGUzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTMyUmVhZGVyO1xuIiwiaW1wb3J0IEJyZXNlbmhhbSBmcm9tICcuL2JyZXNlbmhhbSc7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlcic7XG5pbXBvcnQgQ29kYWJhclJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kYWJhcl9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX3JlYWRlcic7XG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl81X3JlYWRlcic7XG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX2VfcmVhZGVyJztcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuLi9yZWFkZXIvaTJvZjVfcmVhZGVyJztcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyLzJvZjVfcmVhZGVyJztcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzJfcmVhZGVyJztcblxuY29uc3QgUkVBREVSUyA9IHtcbiAgICBjb2RlXzEyOF9yZWFkZXI6IENvZGUxMjhSZWFkZXIsXG4gICAgZWFuX3JlYWRlcjogRUFOUmVhZGVyLFxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcbiAgICBlYW5fMl9yZWFkZXI6IEVBTjJSZWFkZXIsXG4gICAgZWFuXzhfcmVhZGVyOiBFQU44UmVhZGVyLFxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXG4gICAgY29kZV8zOV92aW5fcmVhZGVyOiBDb2RlMzlWSU5SZWFkZXIsXG4gICAgY29kYWJhcl9yZWFkZXI6IENvZGFiYXJSZWFkZXIsXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxuICAgIHVwY19lX3JlYWRlcjogVVBDRVJlYWRlcixcbiAgICBpMm9mNV9yZWFkZXI6IEkyb2Y1UmVhZGVyLFxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcbiAgICBjb2RlXzkzX3JlYWRlcjogQ29kZTkzUmVhZGVyLFxuICAgIGNvZGVfMzJfcmVhZGVyOiBDb2RlMzJSZWFkZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcbiAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICB9LFxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IF9jYW52YXMgPSB7XG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYmFyY29kZVJlYWRlcnMgPSBbXTtcblxuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgIGluaXRDb25maWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5mcmVxdWVuY3knKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5LmNsYXNzTmFtZSA9ICdmcmVxdWVuY3knO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMucGF0dGVybkJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gJ3BhdHRlcm5CdWZmZXInO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgucGF0dGVybiA9IF9jYW52YXMuZG9tLnBhdHRlcm4uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FudmFzLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFJlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25maWcucmVhZGVycy5mb3JFYWNoKChyZWFkZXJDb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xuICAgICAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZm9yZSByZWdpc3RlcmluZyByZWFkZXI6ICcsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMucHVzaChyZWFkZXJPYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlZ2lzdGVyZWQgUmVhZGVyczogJHtfYmFyY29kZVJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzW2ldLnByb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGFtb3VudCAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgICAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgICAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSlcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGV4dCAtPSBNYXRoLmNlaWwoZXh0IC8gMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZShib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzFdWzFdIC0gYm94WzBdWzFdKSAvIDIgKyBib3hbMF1bMV0sXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogKGJveFszXVswXSAtIGJveFsyXVswXSkgLyAyICsgYm94WzJdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbM11bMV0gLSBib3hbMl1bMV0pIC8gMiArIGJveFsyXVsxXSxcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRGcmVxdWVuY3koYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQnJlc2VuaGFtLnRvQmluYXJ5TGluZShiYXJjb2RlTGluZSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50UGF0dGVybihiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlUGF0dGVybihiYXJjb2RlTGluZS5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzbGljZXMgdGhlIGdpdmVuIGFyZWEgYXBhcnQgYW5kIHRyaWVzIHRvIGRldGVjdCBhIGJhcmNvZGUtcGF0dGVyblxuICAgICAgICAgKiBmb3IgZWFjaCBzbGljZS4gSXQgcmV0dXJucyB0aGUgZGVjb2RlZCBiYXJjb2RlLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGJveFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lQW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSk7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlcyA9IDE2O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGlyO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHhkaXIgPSBNYXRoLnNpbihsaW5lQW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgeWRpciA9IE1hdGguY29zKGxpbmVBbmdsZSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBkaXIgKiB4ZGlyLFxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVMZW5ndGgobGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnkgLSBsaW5lWzBdLnkpLCAyKVxuICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS54IC0gbGluZVswXS54KSwgMiksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UgPyBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Zy5kcmF3Qm91bmRpbmdCb3ggJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgY3R4LCB7IGNvbG9yOiAnYmx1ZScsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gZ2V0TGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgcmVzdWx0ICYmIGNvbmZpZy5kZWJ1Zy5kcmF3U2NhbmxpbmUgJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7IGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG11bHRpcGxlIH0gPSBjb25maWc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChSRUFERVJTW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcbiAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsInR5cGUgRXZlbnROYW1lID0gc3RyaW5nO1xuXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcbiAgICBhc3luYz86IGJvb2xlYW47XG4gICAgY2FsbGJhY2s6IEZ1bmN0aW9uO1xuICAgIG9uY2U/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcbiAgICBzdWJzY3JpYmVyczogQXJyYXk8U3Vic2NyaXB0aW9uPjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50cyB7XG4gICAgW2tleTogc3RyaW5nXTogRXZlbnREYXRhO1xufVxuXG5pbnRlcmZhY2UgRXZlbnRJbnRlcmZhY2Uge1xuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZDtcbiAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xuICAgIGxldCBldmVudHM6IEV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xuICAgICAgICBpZiAoIWV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiwgZGF0YTogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHdhcyBub3Qgc3BlY2lmaWVkIG9uIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgICAgICByZXR1cm4gX3N1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSBldmVudDtcblxuICAgICAgICAgICAgLy8gUHVibGlzaCBvbmUtdGltZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICEhc3Vic2NyaWJlci5vbmNlKS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gIXN1YnNjcmliZXIub25jZSk7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYyA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn0oKSk7XG4iLCJjb25zdCBFUlJPUl9ERVNDID0gJ1RoaXMgbWF5IG1lYW4gdGhhdCB0aGUgdXNlciBoYXMgZGVjbGluZWQgY2FtZXJhIGFjY2Vzcywgb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtZWRpYSBBUElzLiBJZiB5b3UgYXJlIHJ1bm5pbmcgaW4gaU9TLCB5b3UgbXVzdCB1c2UgU2FmYXJpLic7XG5cbmludGVyZmFjZSBFcnJvciB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBzdGFjaz86IHN0cmluZztcbiAgICBjb2RlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFcnJvcihgZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWApO1xuICAgICAgICBlcnJvci5jb2RlID0gLTE7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFcnJvcihgZ2V0VXNlck1lZGlhIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAtMTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XG5pbXBvcnQgeyBnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXMgfSBmcm9tICcuLi9jb21tb24vbWVkaWFEZXZpY2VzJztcbmltcG9ydCB7IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCogZGV2OiBjaGVja1ZpZGVvIGZvdW5kICR7dmlkZW8udmlkZW9XaWR0aH1weCB4ICR7dmlkZW8udmlkZW9IZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpOyAvLyBub3QgbGlzdGVkIG9uIE1ETi4uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBNZWRpYVRyYWNrQ29uc3RyYWludHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuXG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IGVudW1lcmF0ZURldmljZXMoKTtcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGRldmljZTogTWVkaWFEZXZpY2VJbmZvKSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xuICAgIGlmICghc3RyZWFtUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICByZXR1cm4gdHJhY2tzICYmIHRyYWNrcz8ubGVuZ3RoID8gdHJhY2tzWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxuICovXG5jb25zdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcyA9IHtcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCB2aWRlb0NvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIGluaXRDYW1lcmEodmlkZW8sIG5ld0NvbnN0cmFpbnRzKTtcbiAgICB9LFxuICAgIHJlbGVhc2UoKTogdm9pZCB7XG4gICAgICAgIC8vIFRPRE86IGkgd29uZGVyIGlmIHRlbGxpbmcgdGhlIFZpZGVvIGVsZW1lbnQgdG8gcGF1c2UoKSBiZWZvcmUgY2FsbGluZyBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKSB3b3VsZCBhbGxldmlhdGUgc29tZSBvZiB0aGUgaXNzdWVzIHdpdGggdGhlIGNhbWVyYSBhcHBlYXJpbmcgdG8gc3RheSBvcGVuIG9uIEFuZHJvaWQgZXZlbiBhZnRlciBzdG9wcGluZy5cbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRyYWNrc1swXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtUmVmID0gbnVsbDtcbiAgICB9LFxuICAgIGVudW1lcmF0ZVZpZGVvRGV2aWNlcyxcbiAgICBnZXRBY3RpdmVTdHJlYW1MYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFjayxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xuIiwiaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCB7XG4gICAgUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yLFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24sXG4gICAgWFlTaXplLFxuICAgIFF1YWdnYUltYWdlRGF0YSxcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCwgbGlzdDogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBsaXN0ICYmIGxpc3Quc29tZSgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSkgYXMgQXJyYXk8a2V5b2YgUXVhZ2dhSlNDb2RlUmVzdWx0PjtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGtleSkgPT4gaXRlbVtrZXldID09PSBjb2RlUmVzdWx0W2tleV0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXNzZXNGaWx0ZXIoXG4gICAgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIGZpbHRlcjogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbiB8IHVuZGVmaW5lZCxcbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyKGNvZGVSZXN1bHQpIDogdHJ1ZTtcbn1cblxuaW50ZXJmYWNlIFJlc3VsdENvbGxlY3RvciB7XG4gICAgYWRkUmVzdWx0OiAoZGF0YTogUXVhZ2dhSW1hZ2VEYXRhLCBpbWFnZVNpemU6IFhZU2l6ZSwgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KSA9PiB2b2lkO1xuICAgIGdldFJlc3VsdHM6ICgpID0+IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUoY29uZmlnOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3Rvcik6IFJlc3VsdENvbGxlY3RvciB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcbiAgICAgICAgbGV0IGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5ID8/IDIwO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gY29uZmlnLmNhcHR1cmUgPT09IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgcmV0dXJuICEhY2FwYWNpdHlcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QgYXMgQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PilcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0geyB9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3SW1hZ2UoZGF0YSwgaW1hZ2VTaXplLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bHRzKCk6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IERldkNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGcmVxdWVuY3k6IGZhbHNlLFxuICAgICAgICAgICAgZHJhd1NjYW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dDYW52YXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93U2tlbGV0b246IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZXZDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBOb2RlQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgUHJvZENvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogNCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9kQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBEZXZDb25maWcgZnJvbSAnLi9jb25maWcuZGV2JztcbmltcG9ydCBOb2RlQ29uZmlnIGZyb20gJy4vY29uZmlnLm5vZGUnO1xuaW1wb3J0IFByb2RDb25maWcgZnJvbSAnLi9jb25maWcucHJvZCc7XG5cbi8vIEB0cy1pZ25vcmUgLy8gVE9ETzogdGhpcyBwcm9kdWNlcyBhIGJpemFycmUgdHlwZXNjcmlwdCBlcnJvclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG5jb25zdCBRdWFnZ2FDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0gRU5WLmRldmVsb3BtZW50XG4gICAgPyBEZXZDb25maWdcbiAgICA6IEVOVi5ub2RlXG4gICAgICAgID8gTm9kZUNvbmZpZ1xuICAgICAgICA6IFByb2RDb25maWc7XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gXCJjb21tb24vaW1hZ2Vfd3JhcHBlclwiO1xuXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XG4gICAgcHVibGljIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XG5cbiAgICBwdWJsaWMgZnJhbWVncmFiYmVyOiBhbnk7XG5cbiAgICBwdWJsaWMgaW5wdXRJbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXI7XG5cbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHVibGljIGJveFNpemU6IGFueTtcblxuICAgIHB1YmxpYyByZXN1bHRDb2xsZWN0b3I6IGFueTtcblxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XG5cbiAgICBwdWJsaWMgd29ya2VyUG9vbDogYW55W10gPSBbXTtcblxuICAgIHB1YmxpYyBvblVJVGhyZWFkID0gdHJ1ZTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcbiAgICBpbWFnZTogYW55O1xuICAgIG92ZXJsYXk6IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRhaW5lciB7XG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9tOiBDYW52YXNJbmZvO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICAgICAgdGhpcy5kb20gPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+Pjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLy8gVE9ETzogSXQncyBwcmV0dHkgbGlrZWx5IHRoYXQgdGhpcyBzaGFyZXMgY29kZSB3aXRoIHRoZSBicm93c2VyIHZlcnNpb24sIGludmVzdGlnYXRlIHRoYXRcbi8vIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGlucHV0X3N0cmVhbSBtb2R1bGUgdXNlZCBmb3IgdGhlIE5vZGUgYnVuZGxlLlxuLy8gd2VicGFjay5jb25maWcuanMgKnJlcGxhY2VzKiB0aGlzIHdpdGggaW5wdXRfc3RyZWFtX2Jyb3dzZXIudHMgd2hlbiB0aGUgYnVuZGxlIGlzIGJlaW5nIGJ1aWx0IGZvciBicm93c2VyLlxuXG5pbXBvcnQgR2V0UGl4ZWxzIGZyb20gJ2dldC1waXhlbHMnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IHsgUG9pbnQsIFhZU2l6ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlVmlkZW9TdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlTGl2ZVN0cmVhbSBub3QgYXZhaWxhYmxlJyk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IG1pbWU6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBzcmM6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogZnJhbWUgc2hvdWxkIGJlIGEgdHlwZSBOZEFycmF5LCBidXQgTmRBcnJheSBkb2Vzbid0IGhhdmUgdHMgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gVE9ETzogdGhlcmUgaXMgYSB0cy1uZGFycmF5IHRoYXQgbWlnaHQgd29yaywgdGhvdWdoXG4gICAgICAgIGxldCBmcmFtZTogYW55ID0gbnVsbDtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgICAgY29uc3QgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gLy8gZmFsc2UgZXNsaW50IGVycm9ycz8gd2VpcmQuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgICAgICAgICAgR2V0UGl4ZWxzKGJhc2VVcmwsIF9jb25maWc/Lm1pbWUsIChlcnIsIHBpeGVscykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKioqKiBxdWFnZ2EgbG9hZEltYWdlcyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY29kaW5nIHBpeGVscyBpbiBsb2FkSW1hZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKiBJbnB1dFN0cmVhbU5vZGUgcGl4ZWxzLnNoYXBlJywgcGl4ZWxzLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGZyYW1lID0gcGl4ZWxzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gcGl4ZWxzLnNoYXBlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2NvbmZpZy5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHdpZHRoIC8gaGVpZ2h0ID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9jb25maWcuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA6IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgodykge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQoaCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IF9jb25maWc/LnNyYztcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHN6KSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHN6Lng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHN6Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8qIFdvcmtlciBmdW5jdGlvbnMuIFRoZXNlIGFyZSBzdHJhaWdodCBmcm9tIHRoZSBvcmlnaW5hbCBxdWFnZ2EuanMgZmlsZS5cbiAqIE5vdCBwcmVzZW50bHkgdXNlZCwgYXMgd29ya2VyIHN1cHBvcnQgaXMgbm9uLWZ1bmN0aW9uYWwuICBLZWVwaW5nIHRoZW0gYXJvdW5kIHRlbXBvcmFyaWx5XG4gKiB0byByZWZlciB0byB1bnRpbCBpdCBpcyByZS1pbXBsZW1lbnRlZC4gV2UgbWF5IGJlIGFibGUgdG8gZml4L3VzZSBzb21lIG9mIHRoaXMuXG4gKi9cblxuaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnIH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5cbi8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IGludGVyZmFjZSBmb3IgRnJhbWVHcmFiYmVyXG5cbmludGVyZmFjZSBRV29ya2VyVGhyZWFkIHtcbiAgICBpbWFnZURhdGE6IFVpbnQ4QXJyYXk7XG4gICAgYnVzeTogYm9vbGVhbjtcbiAgICB3b3JrZXI6IFdvcmtlcjtcbn1cblxubGV0IHdvcmtlclBvb2w6IEFycmF5PFFXb3JrZXJUaHJlYWQ+ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXb3JrZXJzKGZyYW1lR3JhYmJlcjogYW55KSB7XG4gICAgbGV0IGF2YWlsYWJsZVdvcmtlcjogUVdvcmtlclRocmVhZDtcbiAgICBpZiAod29ya2VyUG9vbC5sZW5ndGgpIHtcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoKHdvcmtlclRocmVhZCkgPT4gIXdvcmtlclRocmVhZC5idXN5KVswXTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgZnJhbWVHcmFiYmVyLmF0dGFjaERhdGEoYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJhbWVHcmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB9LCBbYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZy5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2UoZmFjdG9yeSkge1xuICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciBRdWFnZ2EgPSBmYWN0b3J5KCkuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFRdWFnZ2EpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyAnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbi8vIEB0cy1pZ25vcmVcbiAgICB2YXIgaW1hZ2VXcmFwcGVyO1xuXG4vLyBAdHMtaWdub3JlXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ3Byb2Nlc3NlZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2VSZWFkeSgpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuLy8gQHRzLWlnbm9yZVxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IGUuZGF0YS5zaXplLnksXG4gICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBRdWFnZ2EuaW5pdChjb25maWcsIHdvcmtlckludGVyZmFjZVJlYWR5LCBpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgUXVhZ2dhLm9uUHJvY2Vzc2VkKG9uUHJvY2Vzc2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBRdWFnZ2Euc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAnc2V0UmVhZGVycycpIHtcbiAgICAgICAgICAgIFF1YWdnYS5zZXRSZWFkZXJzKGUuZGF0YS5yZWFkZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncmVnaXN0ZXJSZWFkZXInKSB7XG4gICAgICAgICAgICBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIoZS5kYXRhLm5hbWUsIGUuZGF0YS5yZWFkZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xuICAgIHZhciBibG9iLFxuICAgICAgICBmYWN0b3J5U291cmNlO1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZhY3RvcnlTb3VyY2UgPSBfX2ZhY3RvcnlTb3VyY2VfXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXG4gICAgICAgIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG5cbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0V29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtOiBhbnksIGNiOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xuXG4gICAgY29uc3Qgd29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkID0ge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAqIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYih3b3JrZXJUaHJlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBob3cgdG8gdGhyZWFkIHB1Ymxpc2hSZXN1bHQgaW50byBoZXJlP1xuICAgICAgICAgICAgLy8gcHVibGlzaFJlc3VsdChlLmRhdGEucmVzdWx0LCB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGVycm9yOiAnICsgZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgc2l6ZTogeyB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSB9LFxuICAgICAgICBpbWFnZURhdGE6IHdvcmtlclRocmVhZC5pbWFnZURhdGEsXG4gICAgICAgIGNvbmZpZzogY29uZmlnRm9yV29ya2VyKGNvbmZpZyksXG4gICAgfSwgW3dvcmtlclRocmVhZC5pbWFnZURhdGEuYnVmZmVyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RXb3JrZXJQb29sKGNhcGFjaXR5OiBudW1iZXIsIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbT86IGFueSwgY2I/OiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIHdvcmtlclBvb2wubGVuZ3RoO1xuICAgIGlmIChpbmNyZWFzZUJ5ID09PSAwICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSB3b3JrZXJQb29sLnNsaWNlKGluY3JlYXNlQnkpO1xuICAgICAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgdGVybWluYXRlZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3b3JrZXJJbml0aWFsaXplZCA9ICh3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQpID0+IHtcbiAgICAgICAgICAgIHdvcmtlclBvb2wucHVzaCh3b3JrZXJUaHJlYWQpO1xuICAgICAgICAgICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5ICYmIGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluY3JlYXNlQnk7IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRXb3JrZXIoY29uZmlnLCBpbnB1dFN0cmVhbSwgd29ya2VySW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBhbnkpIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3JlZ2lzdGVyUmVhZGVyJywgbmFtZSwgcmVhZGVyIH0pKTtcbn1cbiIsImltcG9ydCB7IElucHV0U3RyZWFtVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBuZWVkIHRvIGNyZWF0ZSBhbiBJbnB1dFN0cmVhbSB0eXBlc2NyaXB0IGludGVyZmFjZSwgc28gd2UgZG9uJ3QgaGF2ZSBhbiBcImFueVwiIGluIHRoZSBuZXh0IGxpbmVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSW5wdXRTdHJlYW0odHlwZTogSW5wdXRTdHJlYW1UeXBlID0gJ0xpdmVTdHJlYW0nLCB2aWV3cG9ydDogRWxlbWVudCB8IG51bGwsIElucHV0U3RyZWFtOiBhbnkpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnVmlkZW9TdHJlYW0nOiB7XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0ltYWdlU3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiB7IGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVJbWFnZVN0cmVhbSgpIH07XG4gICAgICAgIGNhc2UgJ0xpdmVTdHJlYW0nOiB7XG4gICAgICAgICAgICBsZXQgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHZpZGVvID0gdmlld3BvcnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQodmlkZW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgKiBzZXR1cElucHV0U3RyZWFtIGludmFsaWQgdHlwZSAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4geyB2aWRlbzogbnVsbCwgaW5wdXRTdHJlYW06IG51bGwgfTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuZXhwb3J0IHR5cGUgQm94ID0gQXJyYXk8WyBudW1iZXIsIG51bWJlciBdPjtcblxuZXhwb3J0IHR5cGUgTGluZSA9IFsgUG9pbnQsIFBvaW50IF07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlQm94KGJveDogQm94LCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxldCBjb3JuZXIgPSBib3gubGVuZ3RoO1xuICAgIHdoaWxlIChjb3JuZXItLSkge1xuICAgICAgICBib3hbY29ybmVyXVswXSArPSB4T2Zmc2V0O1xuICAgICAgICBib3hbY29ybmVyXVsxXSArPSB5T2Zmc2V0O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmU6IExpbmUsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGluZVswXS54ICs9IHhPZmZzZXQ7XG4gICAgbGluZVswXS55ICs9IHlPZmZzZXQ7XG4gICAgbGluZVsxXS54ICs9IHhPZmZzZXQ7XG4gICAgbGluZVsxXS55ICs9IHlPZmZzZXQ7XG59XG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCB9IGZyb20gJy4uL1F1YWdnYUNvbnRleHQnO1xuaW1wb3J0IF9pbml0QnVmZmVycyBmcm9tICcuL2luaXRCdWZmZXJzJztcbmltcG9ydCBfZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgX2luaXRDYW52YXMgZnJvbSAnLi9pbml0Q2FudmFzJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5pbXBvcnQgSW5wdXRTdHJlYW0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbSc7XG5pbXBvcnQgRnJhbWVHcmFiYmVyIGZyb20gJy4uL2lucHV0L2ZyYW1lX2dyYWJiZXIuanMnO1xuaW1wb3J0ICogYXMgUVdvcmtlcnMgZnJvbSAnLi9xd29ya2VyJztcbmltcG9ydCBzZXR1cElucHV0U3RyZWFtIGZyb20gJy4vc2V0dXBJbnB1dFN0cmVhbSc7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4uL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IHsgQmFyY29kZUluZm8gfSBmcm9tICcuLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IHsgbW92ZUxpbmUsIG1vdmVCb3ggfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHModGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLCB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdG9yKTtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2wodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYXRlQW5kRGVjb2RlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB8fCB7fTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGRlY29kZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBkZWxheSA9IDEwMDAgLyAodGhpcy5jb250ZXh0LmNvbmZpZz8uZnJlcXVlbmN5IHx8IDYwKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0IHx8IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKz0gZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmV3RnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5ld0ZyYW1lKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG5cbiAgICBzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkICYmIHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb250aW51b3VzVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKDApO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0gJiYgdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogUXVhZ2dhSlNSZWFkZXJDb25maWcpOiB2b2lkIHtcbiAgICAgICAgQmFyY29kZURlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vcmVhZGVyL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuaW1wb3J0IFF1YWdnYSBmcm9tICcuL3F1YWdnYS9xdWFnZ2EnO1xuXG5jb25zdCBpbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbmNvbnN0IF9jb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuY29uc3QgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgY2IsIGltYWdlV3JhcHBlciwgcXVhZ2dhSW5zdGFuY2UgPSBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xuICAgICAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=